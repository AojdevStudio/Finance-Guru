# Code Style & Conventions
> Auto-generated by codebase mapper

## Overview
Finance Guru™ employs a strict 3-layer architecture with comprehensive type hints, Pydantic validation, and educational documentation. Code follows Python 3.12+ standards with consistent naming conventions, import ordering, and error handling patterns across all modules.

## Python Version & Dependencies
- **Minimum Version**: Python 3.12+
- **Package Manager**: `uv` (unified virtual environment and package management)
- **Key Dependencies**: pandas, numpy, scipy, scikit-learn, pydantic (2.10.6+), yfinance, streamlit
- **Dev Dependencies**: pytest (9.0.2+), pytest-cov, black, mypy

**File**: `/Users/ossieirondi/Documents/Irondi-Household/family-office/pyproject.toml`

## 3-Layer Architecture Pattern

All financial analysis tools follow this strict separation:

```
Layer 1: Pydantic Models (src/models/)
    ↓
Layer 2: Calculator Classes (src/analysis/, src/strategies/, src/utils/)
    ↓
Layer 3: CLI Interfaces (*_cli.py files)
```

**Why**: Type safety → Business logic → I/O separation enables testability and reusability.

### Layer 1: Pydantic Models

**Location**: `/Users/ossieirondi/Documents/Irondi-Household/family-office/src/models/`

All data structures use Pydantic v2 for validation and serialization.

#### Model Definition Pattern

```python
# src/models/risk_inputs.py
from datetime import date
from typing import Literal
from pydantic import BaseModel, Field, field_validator

class PriceDataInput(BaseModel):
    """
    Historical price data for risk calculations.

    WHAT: Container for time-series price data
    WHY: Ensures price data is valid before risk calculations begin
    VALIDATES:
        - Prices are positive
        - Dates are chronologically sorted
        - Minimum 30 data points
        - Equal prices/dates length
    """

    ticker: str = Field(
        ...,
        description="Stock ticker symbol (e.g., 'TSLA')",
        min_length=1,
        max_length=10,
        pattern=r"^[A-Z\-\.]+$",
    )

    prices: list[float] = Field(
        ...,
        description="Historical closing prices (min 30 days)",
        min_length=30,
    )

    dates: list[date] = Field(
        ...,
        description="Corresponding dates in YYYY-MM-DD format",
        min_length=30,
    )

    @field_validator("prices")
    @classmethod
    def prices_must_be_positive(cls, v: list[float]) -> list[float]:
        """Ensure all prices are positive."""
        if any(price <= 0 for price in v):
            raise ValueError("All prices must be positive")
        return v

    @field_validator("dates")
    @classmethod
    def dates_must_be_sorted(cls, v: list[date]) -> list[date]:
        """Ensure dates are in chronological order."""
        if v != sorted(v):
            raise ValueError("Dates must be in chronological order")
        return v

    class Config:
        arbitrary_types_allowed = True  # For pandas/numpy types
```

#### Field Definition Standards

- Use `Field(...)` with descriptive parameters for all fields
- Include `description` for complex metrics
- Use `min_length`, `max_length`, `gt`, `ge`, `lt`, `le` for validation
- Use `pattern` for string regex validation
- Add helpful error messages in validators
- Set `arbitrary_types_allowed = True` when using pandas/numpy

#### Validator Patterns

- Use `@field_validator` (Pydantic v2) not `@validator` (v1)
- Use `@classmethod` for all validators
- Return the validated value
- Raise `ValueError` with clear message
- Single validator can handle multiple fields: `@field_validator('field1', 'field2')`

**Example Files**:
- `/Users/ossieirondi/Documents/Irondi-Household/family-office/src/models/risk_inputs.py` (comprehensive validators)
- `/Users/ossieirondi/Documents/Irondi-Household/family-office/src/models/options_inputs.py` (complex models)
- `/Users/ossieirondi/Documents/Irondi-Household/family-office/src/models/volatility_inputs.py` (OHLC data)

### Layer 2: Calculator Classes

**Location**: `/Users/ossieirondi/Documents/Irondi-Household/family-office/src/analysis/`, `src/strategies/`, `src/utils/`

Calculator classes contain all business logic and operate on Pydantic models.

#### Class Definition Pattern

```python
# src/analysis/risk_metrics.py
"""
Risk Metrics Calculator for Finance Guru™

ARCHITECTURE NOTE:
This is Layer 2 of our 3-layer architecture:
    Layer 1: Pydantic Models - Data validation
    Layer 2: Calculator Classes (THIS FILE) - Business logic
    Layer 3: CLI Interface - Agent integration
"""

from src.models.risk_inputs import (
    PriceDataInput,
    RiskCalculationConfig,
    RiskMetricsOutput,
)

class RiskCalculator:
    """
    Comprehensive risk metrics calculator.

    WHAT: Calculates all major risk metrics for Finance Guru agents
    WHY: Provides validated, type-safe risk analysis
    HOW: Uses Pydantic models for I/O, numpy/pandas for calculations

    Attributes:
        config: Risk calculation configuration
    """

    def __init__(self, config: RiskCalculationConfig):
        """
        Initialize calculator with configuration.

        Args:
            config: Validated configuration (Pydantic ensures correctness)
        """
        self.config = config

    def calculate_risk_metrics(
        self,
        price_data: PriceDataInput,
        benchmark_data: PriceDataInput | None = None,
    ) -> RiskMetricsOutput:
        """
        Calculate all risk metrics for a given price series.

        EDUCATIONAL NOTE:
        Explain why this calculation matters and what it means.
        Include interpretation guidance for agents.

        Args:
            price_data: Historical price data (validated by Pydantic)
            benchmark_data: Optional benchmark for beta/alpha calculation

        Returns:
            RiskMetricsOutput with all calculated metrics (validated)

        Raises:
            ValueError: If data is insufficient
        """
        if len(price_data.prices) < 30:
            raise ValueError("Minimum 30 data points required")

        # Implementation
        pass

    def _calculate_returns(self) -> float:
        """Private helper method with underscore prefix."""
        pass
```

#### Calculator Patterns

1. **Constructor**: Accept Pydantic models as inputs
2. **Public Methods**: Descriptive names, return Pydantic models
3. **Private Methods**: Prefix with `_`, no external visibility
4. **No Side Effects**: Pure functions, no I/O, no state mutation
5. **Caching**: Cache expensive calculations in `__init__`
6. **Type Hints**: Always include parameter and return types
7. **Docstrings**: Include WHAT, WHY, HOW structure

#### Calculation Patterns

- Use vectorized operations (pandas/numpy) not loops
- Cache frequently-used calculations:
  ```python
  def __init__(self, data: PriceDataInput):
      self.data = data
      self._returns = self._calculate_returns()  # Cache once
  ```
- Handle edge cases (zero volatility, empty data, etc.)
- Use numpy constants:
  ```python
  TRADING_DAYS_PER_YEAR = 252
  annual_volatility = daily_vol * np.sqrt(TRADING_DAYS_PER_YEAR)
  ```

**Example Files**:
- `/Users/ossieirondi/Documents/Irondi-Household/family-office/src/analysis/risk_metrics.py` (risk calculations)
- `/Users/ossieirondi/Documents/Irondi-Household/family-office/src/utils/volatility.py` (volatility indicators)
- `/Users/ossieirondi/Documents/Irondi-Household/family-office/src/analysis/itc_risk.py` (API integration)

### Layer 3: CLI Interfaces

**Location**: Files ending in `_cli.py` in `src/analysis/`, `src/strategies/`, `src/utils/`

CLI scripts provide command-line access and integrate with Finance Guru agents.

#### CLI Pattern

```python
# src/analysis/risk_metrics_cli.py
#!/usr/bin/env python3
"""
Risk Metrics CLI for Finance Guru™

Usage:
    uv run python src/analysis/risk_metrics_cli.py TICKER [options]

Examples:
    uv run python src/analysis/risk_metrics_cli.py TSLA --days 90
    uv run python src/analysis/risk_metrics_cli.py SPY --output json
    uv run python src/analysis/risk_metrics_cli.py NVDA --benchmark SPY
"""

import argparse
import sys
from pathlib import Path

# Add project root to path
project_root = Path(__file__).parent.parent.parent
sys.path.insert(0, str(project_root))

from src.utils.market_data import get_prices
from src.models.risk_inputs import PriceDataInput, RiskCalculationConfig
from src.analysis.risk_metrics import RiskCalculator

def parse_args():
    """Parse command-line arguments."""
    parser = argparse.ArgumentParser(
        description='Calculate comprehensive risk metrics',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )
    parser.add_argument('ticker', help='Stock ticker symbol')
    parser.add_argument(
        '--days',
        type=int,
        default=90,
        help='Number of days of data (default: 90)'
    )
    parser.add_argument(
        '--output',
        choices=['text', 'json'],
        default='text',
        help='Output format (default: text)'
    )
    return parser.parse_args()

def main():
    """Main entry point."""
    args = parse_args()

    try:
        # Fetch and validate data
        prices = get_prices(args.ticker, days=args.days)
        data = PriceDataInput(ticker=args.ticker, prices=prices)

        # Calculate
        calculator = RiskCalculator(RiskCalculationConfig())
        result = calculator.calculate_risk_metrics(data)

        # Format output
        if args.output == 'json':
            print(result.model_dump_json(indent=2))
        else:
            print(f"Risk Metrics for {args.ticker}")
            print(f"Sharpe Ratio: {result.sharpe_ratio:.2f}")

    except ValueError as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == '__main__':
    main()
```

#### CLI Patterns

1. **Shebang**: Include `#!/usr/bin/env python3` at top
2. **Docstring**: Include module-level docstring with usage examples
3. **Argparse**: Use `argparse.ArgumentParser` with descriptive help
4. **Path Setup**: Add project root to sys.path
5. **Error Handling**: Catch exceptions, exit with code 1
6. **Output Formats**: Support both text and JSON
7. **No Business Logic**: CLI only handles I/O
8. **Help Epilog**: Use `epilog=__doc__` to show examples in help

**Example Files**:
- `/Users/ossieirondi/Documents/Irondi-Household/family-office/src/analysis/risk_metrics_cli.py`
- `/Users/ossieirondi/Documents/Irondi-Household/family-office/src/analysis/correlation_cli.py`
- `/Users/ossieirondi/Documents/Irondi-Household/family-office/src/analysis/itc_risk_cli.py`

## Type Hints & PEP 484

**Requirement**: Always use type hints for all function signatures.

### Type Hint Patterns

```python
# ✓ Good
def calculate_sharpe(
    returns: pd.Series,
    risk_free_rate: float = 0.0,
) -> float:
    """Calculate Sharpe ratio."""
    pass

# ✗ Bad (no type hints)
def calculate_sharpe(returns, risk_free_rate=0.0):
    """Calculate Sharpe ratio."""
    pass
```

### Union Types

Use `|` syntax (Python 3.10+):

```python
# ✓ Good (Python 3.10+)
def calculate(
    data: PriceDataInput | None = None
) -> float | None:
    pass

# ✗ Avoid (older Union syntax)
def calculate(data: Union[PriceDataInput, None] = None) -> Optional[float]:
    pass
```

### Generic Collections

Use lowercase types:

```python
# ✓ Good (Python 3.9+)
def process_tickers(tickers: list[str]) -> dict[str, float]:
    pass

# ✗ Avoid (requires typing import)
def process_tickers(tickers: List[str]) -> Dict[str, float]:
    pass
```

## Naming Conventions

### Classes
- **Format**: `PascalCase`
- **Examples**: `RiskCalculator`, `VolatilityCalculator`, `PortfolioOptimizer`
- **Pattern**: Noun + optional descriptor

### Functions & Methods
- **Format**: `snake_case`
- **Examples**: `calculate_var`, `fetch_prices`, `parse_arguments`
- **Private Methods**: Prefix with `_`: `_calculate_returns`, `_validate_data`
- **Pattern**: Verb + noun or verb + descriptor

### Variables
- **Format**: `snake_case`
- **Examples**: `price_data`, `annual_volatility`, `risk_free_rate`
- **Constants**: `UPPER_SNAKE_CASE` (rarely used, most are in models)

### Files
- **Layer 2 Calculators**: `{noun}.py` (e.g., `risk_metrics.py`, `correlation.py`)
- **Layer 3 CLIs**: `{noun}_cli.py` (e.g., `risk_metrics_cli.py`)
- **Layer 1 Models**: `{noun}_inputs.py` (e.g., `risk_inputs.py`, `volatility_inputs.py`)
- **Test Files**: `test_{module_name}.py` (e.g., `test_risk_metrics.py`)

### Modules & Directories
- **Location**: `/src/{category}/{module}.py`
- **Categories**:
  - `analysis/` - Financial analysis (risk, correlation, factors)
  - `strategies/` - Trading/portfolio strategies (backtesting, optimization)
  - `utils/` - Utilities (market data, momentum, volatility)
  - `models/` - Pydantic data models
  - `ui/` - Streamlit dashboard components
  - `config.py` - Project configuration

**Example Files**:
- `/Users/ossieirondi/Documents/Irondi-Household/family-office/src/analysis/risk_metrics.py`
- `/Users/ossieirondi/Documents/Irondi-Household/family-office/src/analysis/risk_metrics_cli.py`
- `/Users/ossieirondi/Documents/Irondi-Household/family-office/src/models/risk_inputs.py`

## Import Ordering

Follow this strict ordering (PEP 8):

```python
# 1. __future__ imports (if needed)
from __future__ import annotations

# 2. Standard library (alphabetical)
import argparse
import os
import sys
import time
import warnings
from datetime import date, datetime, timedelta
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple, Union

# 3. Third-party (alphabetical)
import numpy as np
import pandas as pd
import requests
import yfinance as yf
from pydantic import BaseModel, Field, field_validator
from scipy import stats
from sklearn.linear_model import LinearRegression

# 4. Local (relative imports)
from src.models.risk_inputs import (
    PriceDataInput,
    RiskCalculationConfig,
    RiskMetricsOutput,
)
from src.analysis.risk_metrics import RiskCalculator
from src.utils.market_data import get_prices
```

### Multi-line Import Example

```python
from src.models.correlation_inputs import (
    CorrelationConfig,
    CorrelationOutput,
    PortfolioPriceData,
)
```

**Example Files**:
- `/Users/ossieirondi/Documents/Irondi-Household/family-office/src/analysis/risk_metrics_cli.py` (complete example)
- `/Users/ossieirondi/Documents/Irondi-Household/family-office/src/analysis/itc_risk_cli.py`

## Docstring Style

Use Google-style docstrings with WHAT/WHY/HOW structure.

### Module Docstring

```python
"""
Risk Metrics Calculator for Finance Guru™

This module implements comprehensive risk calculations using validated Pydantic models.
All calculations follow industry-standard financial engineering formulas.

ARCHITECTURE NOTE:
This is Layer 2 of our 3-layer architecture:
    Layer 1: Pydantic Models - Data validation (risk_inputs.py)
    Layer 2: Calculator Classes (THIS FILE) - Business logic
    Layer 3: CLI Interface - Agent integration

EDUCATIONAL CONTEXT:
Each calculation includes detailed explanations of:
- WHAT: The metric being calculated
- WHY: Why this metric matters for risk assessment
- HOW: The mathematical formula being used
- INTERPRETATION: How to read the results

RISK METRICS IMPLEMENTED:
1. Value at Risk (VaR) - Historical & Parametric methods
2. Conditional VaR (CVaR) - Expected Shortfall
3. Sharpe Ratio - Risk-adjusted return
4. Maximum Drawdown - Worst peak-to-trough decline

Author: Finance Guru™ Development Team
Created: 2025-10-13
"""
```

### Class Docstring

```python
class RiskCalculator:
    """
    Comprehensive risk metrics calculator.

    WHAT: Calculates all major risk metrics for Finance Guru agents
    WHY: Provides validated, type-safe risk analysis for portfolio decisions
    HOW: Uses Pydantic models for I/O, numpy/pandas for calculations

    USAGE EXAMPLE:
        config = RiskCalculationConfig(confidence_level=0.95)
        calculator = RiskCalculator(config)
        results = calculator.calculate_risk_metrics(price_data)
        print(f"Sharpe Ratio: {results.sharpe_ratio:.2f}")

    Attributes:
        config: Validated configuration (RiskCalculationConfig)
    """
```

### Method Docstring

```python
def calculate_var(
    self,
    returns: pd.Series,
    confidence: float = 0.95,
) -> float:
    """
    Calculate Value at Risk using historical method.

    VaR represents the maximum expected loss over a given time period
    at a specified confidence level. This is a key risk metric used by
    financial institutions to assess portfolio risk.

    Args:
        returns: Daily returns series (pct_change)
        confidence: Confidence level (0.95 = 95%)

    Returns:
        VaR as a negative percentage (e.g., -0.034 for -3.4%)

    Raises:
        ValueError: If confidence is not between 0 and 1

    EDUCATIONAL NOTE:
    The historical method uses the empirical distribution of returns.
    This is model-free but requires sufficient historical data (minimum 30 days).
    """
    if not 0 < confidence < 1:
        raise ValueError(f"Confidence must be between 0 and 1, got {confidence}")

    return np.percentile(returns, (1 - confidence) * 100)
```

## Error Handling

### Exception Types

- `ValueError`: Data validation failures, constraint violations
- `TypeError`: Type mismatches (rarely needed with Pydantic)
- `KeyError`: Missing required dictionary keys
- `FileNotFoundError`: Configuration file not found

### Error Handling Pattern

```python
# CLI error handling
try:
    prices = get_prices(ticker, days=days)
    data = PriceDataInput(ticker=ticker, prices=prices)
    calculator = RiskCalculator(data)
    result = calculator.calculate_all()
except ValueError as e:
    print(f"Error: {e}", file=sys.stderr)
    sys.exit(1)
except Exception as e:
    print(f"Unexpected error: {e}", file=sys.stderr)
    sys.exit(1)

# In Calculator classes, validate and raise early:
def calculate_metrics(self, data: PriceDataInput) -> MetricsOutput:
    if len(data.prices) < 30:
        raise ValueError("Minimum 30 data points required")

    if len(data.prices) != len(data.dates):
        raise ValueError("Length mismatch between prices and dates")

    # Proceed with calculation...
```

### Error Message Pattern

```python
# ✓ Good (descriptive, actionable)
raise ValueError(
    f"No data found for ticker {ticker}. "
    f"Verify ticker symbol is valid (e.g., TSLA, AAPL, SPY)"
)

# ✗ Avoid (vague, not helpful)
raise ValueError("Invalid data")
```

**Example Files**:
- `/Users/ossieirondi/Documents/Irondi-Household/family-office/src/analysis/risk_metrics_cli.py`
- `/Users/ossieirondi/Documents/Irondi-Household/family-office/src/analysis/correlation_cli.py`

## Pydantic Usage Patterns

### Model Configuration

```python
class MyModel(BaseModel):
    """My data model."""

    field: pd.Series

    class Config:
        arbitrary_types_allowed = True  # For pandas/numpy types
```

### Field with Validation

```python
from pydantic import Field, field_validator

class PriceDataInput(BaseModel):
    ticker: str = Field(
        ...,
        description="Stock ticker symbol",
        min_length=1,
        max_length=10,
        pattern=r"^[A-Z\-\.]+$",
    )

    prices: list[float] = Field(
        ...,
        description="Historical prices",
        min_length=30,
    )

    @field_validator("prices")
    @classmethod
    def prices_must_be_positive(cls, v: list[float]) -> list[float]:
        if any(price <= 0 for price in v):
            raise ValueError("All prices must be positive")
        return v
```

### Model Serialization

```python
# To JSON string
json_str = model.model_dump_json(indent=2)

# To dict
data_dict = model.model_dump()

# To dict excluding fields
partial_dict = model.model_dump(exclude={'internal_field'})
```

### Optional Fields

```python
from typing import Optional

class AnalysisInput(BaseModel):
    benchmark_ticker: Optional[str] = None
    custom_weights: list[float] | None = None
```

**Example Files**:
- `/Users/ossieirondi/Documents/Irondi-Household/family-office/src/models/risk_inputs.py`
- `/Users/ossieirondi/Documents/Irondi-Household/family-office/src/models/options_inputs.py`

## CLI Argument Patterns

### Standard Flags

```
--days N              Number of historical days (default: 90)
--output {text,json} Output format (default: text)
--benchmark TICKER   Benchmark ticker for comparison (default: SPY)
--confidence 0.95    Confidence level for VaR (default: 0.95)
--rolling N          Rolling window size
--save-to PATH       Save JSON output to file
--full-table         Show complete data table
--list-supported     List supported tickers
```

### Argument Parser Template

```python
def parse_args():
    parser = argparse.ArgumentParser(
        description='Tool description',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )

    parser.add_argument(
        'ticker',
        help='Stock ticker symbol (e.g., TSLA, SPY, BTC)'
    )

    parser.add_argument(
        '--days',
        type=int,
        default=90,
        help='Number of days of historical data (default: 90)'
    )

    parser.add_argument(
        '--output',
        choices=['text', 'json'],
        default='text',
        help='Output format (default: text)'
    )

    parser.add_argument(
        '--benchmark',
        default='SPY',
        help='Benchmark ticker for comparison (default: SPY)'
    )

    return parser.parse_args()
```

**Example Files**:
- `/Users/ossieirondi/Documents/Irondi-Household/family-office/src/analysis/risk_metrics_cli.py`
- `/Users/ossieirondi/Documents/Irondi-Household/family-office/src/analysis/correlation_cli.py`

## Code Comments & Documentation

### Inline Comments

Use sparingly, only for non-obvious logic:

```python
# ✓ Good (explains WHY)
# Use log returns instead of simple returns for normality
returns = np.log(prices / prices.shift(1))

# ✗ Avoid (explains WHAT code does, which is obvious)
# Calculate peak-to-trough decline
peak = np.maximum.accumulate(prices)
```

### Code Examples in Docstrings

```python
def calculate_all(self) -> RiskMetricsOutput:
    """
    Calculate all risk metrics.

    Returns:
        RiskMetricsOutput with all validated metrics

    USAGE EXAMPLE:
        calculator = RiskCalculator(config)
        result = calculator.calculate_all()
        print(f"Sharpe: {result.sharpe_ratio:.2f}")
    """
```

### WHAT/WHY/HOW Structure

Always explain metrics at three levels:

```python
def calculate_var(self, confidence: float = 0.95) -> float:
    """
    Calculate Value at Risk.

    WHAT: VaR represents maximum expected loss at given confidence level.
    For example, 95% VaR of -3.2% means there's a 5% chance daily loss
    exceeds 3.2% based on historical data.

    WHY: VaR is a key risk metric used by banks and institutions for
    regulatory capital requirements and portfolio risk monitoring.

    HOW: Uses historical method - empirical 5th percentile of returns.
    Other methods (parametric, CVaR) available via calculate_var_parametric().

    Args:
        confidence: Confidence level (default: 0.95 for 95% VaR)

    Returns:
        VaR as negative percentage
    """
```

## Code Quality Standards

### Type Checking

```bash
# Run mypy type checker
mypy src/
```

### Code Formatting

```bash
# Black formatter (used in dev dependencies)
black src/ tests/
```

### Constants

```python
# Use constants for magic numbers
TRADING_DAYS_PER_YEAR = 252
DEFAULT_CONFIDENCE_LEVEL = 0.95
MIN_PRICE_DATA_POINTS = 30
```

### Vectorization

Always prefer pandas/numpy operations over loops:

```python
# ✓ Good (vectorized)
returns = prices.pct_change()
volatility = returns.std()

# ✗ Avoid (loop)
returns = []
for i in range(1, len(prices)):
    returns.append((prices[i] - prices[i-1]) / prices[i-1])
```

## Directory Structure

```
src/
├── analysis/              # Layer 2 & 3: Financial analysis tools
│   ├── risk_metrics.py    # Layer 2: Risk calculator
│   ├── risk_metrics_cli.py # Layer 3: CLI interface
│   ├── correlation.py
│   ├── correlation_cli.py
│   ├── itc_risk.py
│   ├── itc_risk_cli.py
│   ├── factors.py
│   ├── factors_cli.py
│   ├── options.py
│   ├── options_chain_cli.py
│   └── __init__.py
│
├── strategies/            # Layer 2 & 3: Portfolio strategies
│   ├── backtester.py      # Layer 2: Backtest engine
│   ├── backtester_cli.py  # Layer 3: CLI
│   ├── optimizer.py
│   ├── optimizer_cli.py
│   └── __init__.py
│
├── utils/                 # Layer 2 & 3: Utility tools
│   ├── market_data.py     # Market data fetching
│   ├── momentum.py
│   ├── momentum_cli.py
│   ├── volatility.py
│   ├── volatility_cli.py
│   ├── moving_averages.py
│   ├── moving_averages_cli.py
│   ├── input_validation.py
│   ├── input_validation_cli.py
│   ├── yaml_generator.py
│   └── __init__.py
│
├── models/                # Layer 1: Pydantic models
│   ├── __init__.py        # Exports all models
│   ├── risk_inputs.py
│   ├── correlation_inputs.py
│   ├── volatility_inputs.py
│   ├── momentum_inputs.py
│   ├── backtest_inputs.py
│   ├── options_inputs.py
│   ├── factors_inputs.py
│   ├── itc_risk_inputs.py
│   ├── portfolio_inputs.py
│   ├── validation_inputs.py
│   ├── yaml_generation_inputs.py
│   └── dashboard_inputs.py
│
├── ui/                    # Streamlit dashboard
│   ├── app.py
│   ├── services/
│   └── widgets/
│
├── config.py              # Project-wide configuration
└── __init__.py
```

## Summary of Key Conventions

1. **Always use Pydantic models** for all data structures
2. **Always use type hints** for all function signatures
3. **Always use 3-layer architecture** (Models → Calculator → CLI)
4. **Follow PEP 8** style guidelines
5. **Use Google-style docstrings** with WHAT/WHY/HOW
6. **Use snake_case** for functions/variables, `PascalCase` for classes
7. **Use educational comments** explaining metrics and calculations
8. **Handle errors explicitly** with descriptive messages
9. **Use vectorized operations** (pandas/numpy) not loops
10. **Cache expensive calculations** in constructors
