---
phase: 08-rolling-tracker-hedge-sizer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/analysis/rolling_tracker.py
autonomous: true

must_haves:
  truths:
    - "RollingTracker loads positions from positions.yaml into validated HedgePosition objects"
    - "get_status() returns each position's current value, P&L, DTE, and urgency markers"
    - "suggest_roll() finds positions within 7-day DTE window and returns top 3 replacement candidates ranked by per-day cost"
    - "log_position() writes a new HedgePosition to positions.yaml"
    - "log_roll() closes old position in positions.yaml, adds new position, appends to roll-history.yaml"
    - "get_history() returns all historical rolls from roll-history.yaml"
    - "American put pricing applies max(bs_price, intrinsic_value) floor"
    - "scan_chain_quiet() wraps scan_chain() suppressing stderr output"
  artifacts:
    - path: "src/analysis/rolling_tracker.py"
      provides: "RollingTracker calculator class with all position management methods"
      exports: ["RollingTracker"]
  key_links:
    - from: "src/analysis/rolling_tracker.py"
      to: "src/models/hedging_inputs.py"
      via: "import HedgePosition, RollSuggestion"
      pattern: "from src\\.models\\.hedging_inputs import"
    - from: "src/analysis/rolling_tracker.py"
      to: "src/config/config_loader.py"
      via: "import load_hedge_config"
      pattern: "from src\\.config import"
    - from: "src/analysis/rolling_tracker.py"
      to: "src/analysis/options_chain_cli.py"
      via: "import scan_chain wrapped with redirect_stderr"
      pattern: "from src\\.analysis\\.options_chain_cli import scan_chain"
    - from: "src/analysis/rolling_tracker.py"
      to: "src/analysis/options.py"
      via: "import price_option for American put pricing"
      pattern: "from src\\.analysis\\.options import price_option"
    - from: "src/analysis/rolling_tracker.py"
      to: "fin-guru-private/hedging/positions.yaml"
      via: "yaml.safe_load/yaml.dump for position persistence"
      pattern: "positions\\.yaml"
---

<objective>
Create the RollingTracker calculator class (Layer 2) that manages hedge positions: loading from YAML, calculating status with live prices, suggesting rolls, logging new positions and rolls, and reading history.

Purpose: This is the core business logic for the rolling tracker CLI. It handles all position lifecycle operations: entry, monitoring, roll suggestion, roll execution recording, and history retrieval. It wraps the existing scan_chain() function to suppress stderr noise and applies an American-style intrinsic value floor to Black-Scholes put pricing.

Output: `src/analysis/rolling_tracker.py` with a RollingTracker class containing all position management methods.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-rolling-tracker-hedge-sizer/08-RESEARCH.md
@.planning/phases/08-rolling-tracker-hedge-sizer/08-CONTEXT.md

# Pattern references (read for exact conventions)
@src/analysis/risk_metrics.py
@src/analysis/options.py
@src/analysis/options_chain_cli.py
@src/models/hedging_inputs.py
@src/config/config_loader.py
@fin-guru-private/hedging/positions.yaml
@fin-guru-private/hedging/roll-history.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RollingTracker class with core infrastructure and get_status()</name>
  <files>src/analysis/rolling_tracker.py</files>
  <action>
Create `src/analysis/rolling_tracker.py` following the Layer 2 calculator conventions from `risk_metrics.py`.

**Module docstring:** Include ARCHITECTURE NOTE (Layer 2 of 3), EDUCATIONAL CONTEXT explaining options position tracking, roll management, and the insurance-like nature of protective puts.

**Imports:**
```python
import sys
import io
import contextlib
import math
from datetime import date, datetime
from pathlib import Path
from typing import Any

import yaml

from src.models.hedging_inputs import HedgePosition, RollSuggestion
from src.config import HedgeConfig, load_hedge_config
from src.analysis.options_chain_cli import scan_chain
from src.analysis.options import price_option
from src.utils.market_data import get_prices
```

**Constants:**
```python
PROJECT_ROOT = Path(__file__).parent.parent.parent
POSITIONS_PATH = PROJECT_ROOT / "fin-guru-private" / "hedging" / "positions.yaml"
ROLL_HISTORY_PATH = PROJECT_ROOT / "fin-guru-private" / "hedging" / "roll-history.yaml"
```

**RollingTracker class:**

Constructor `__init__(self, config: HedgeConfig | None = None, positions_path: Path | None = None, history_path: Path | None = None)`:
- If config is None, call `load_hedge_config()` to get defaults
- Store positions_path (default POSITIONS_PATH) and history_path (default ROLL_HISTORY_PATH)
- Store config as self.config

**Private helper `_scan_chain_quiet()`:**
```python
def _scan_chain_quiet(
    self,
    ticker: str,
    option_type: str = "put",
    otm_min: float = 10.0,
    otm_max: float = 20.0,
    days_min: int = 60,
    days_max: int = 90,
    budget: float | None = None,
    target_contracts: int = 1,
) -> Any:
    """Wrap scan_chain() suppressing its stderr progress messages."""
    stderr_capture = io.StringIO()
    with contextlib.redirect_stderr(stderr_capture):
        return scan_chain(
            ticker=ticker,
            option_type=option_type,
            otm_min=otm_min,
            otm_max=otm_max,
            days_min=days_min,
            days_max=days_max,
            budget=budget,
            target_contracts=target_contracts,
        )
```

**Private helper `_price_put_american()`:**
```python
def _price_put_american(
    self,
    spot: float,
    strike: float,
    days_to_expiry: int,
    volatility: float = 0.30,
) -> float:
    """
    Price an American-style put with intrinsic value floor.

    EDUCATIONAL NOTE:
    Black-Scholes assumes European-style options (exercise only at expiry).
    American puts can be exercised early, so their value is always at least
    the intrinsic value: max(strike - spot, 0). We apply:
        american_price = max(bs_price, intrinsic_value)

    BS-01: This limitation is documented here as the canonical implementation.
    """
    greeks = price_option(
        spot=spot,
        strike=strike,
        days_to_expiry=days_to_expiry,
        volatility=volatility,
        option_type="put",
    )
    bs_price = greeks.price
    intrinsic_value = max(strike - spot, 0.0)
    return max(bs_price, intrinsic_value)
```

**`load_positions()` method:**
```python
def load_positions(self) -> list[dict]:
    """Load active positions from positions.yaml. Returns raw dicts."""
    if not self.positions_path.exists():
        return []
    with open(self.positions_path) as f:
        data = yaml.safe_load(f) or {}
    positions = data.get("positions", [])
    return positions if positions else []
```
Return raw dicts (not HedgePosition objects) because positions.yaml may contain extra metadata fields (reason, protects_layer) that HedgePosition doesn't validate. The CLI can use `HedgePosition.model_validate(pos)` when strict validation is needed.

**`_save_positions()` private method:**
Write positions list back to positions.yaml preserving YAML comments at top.

**`get_status()` method:**
```python
def get_status(self) -> list[dict]:
    """
    Calculate current status for all active positions.

    Returns list of dicts with fields:
    - All HedgePosition fields (ticker, strike, expiry, etc.)
    - dte: int (days to expiry, 0 for inverse ETFs)
    - current_value: float (current option/ETF value per unit)
    - pnl: float (current_value - premium_paid per unit)
    - pnl_pct: float (pnl / premium_paid as percentage)
    - urgency: str ("ROLL" if dte <= 7, "EXPIRING" if dte <= 3, "" otherwise)
    """
```
Implementation:
1. Load positions via `load_positions()`
2. If no positions, return empty list
3. Group positions by ticker to minimize API calls
4. For each unique ticker, fetch spot price via `get_prices(ticker)`
5. For each position:
   - If hedge_type == "put": calculate DTE as `(expiry - date.today()).days`, estimate current value via `_price_put_american()` with default 0.30 IV, calculate P&L
   - If hedge_type == "inverse_etf": DTE is 0 (no expiry), current_value is spot price times quantity, P&L is current_value minus entry cost
   - Set urgency markers: "EXPIRING" if DTE <= 3, "ROLL" if DTE <= 7 (and DTE > 3), "" otherwise
   - Auto-detect expired: if DTE <= 0 for puts, mark with urgency "EXPIRED"
6. Return list of enriched dicts

Handle errors gracefully: if price fetch fails for a ticker, set current_value to None and note in a warning field.

**`__all__` at bottom:**
```python
__all__ = ["RollingTracker"]
```
  </action>
  <verify>
```bash
uv run python -c "
from src.analysis.rolling_tracker import RollingTracker
tracker = RollingTracker()
print(f'Config roll window: {tracker.config.roll_window_days}')
positions = tracker.load_positions()
print(f'Positions loaded: {len(positions)}')
print('RollingTracker core OK')
"
```

Verify American put pricing:
```bash
uv run python -c "
from src.analysis.rolling_tracker import RollingTracker
tracker = RollingTracker()
# Deep ITM put: intrinsic should dominate
price = tracker._price_put_american(spot=400.0, strike=500.0, days_to_expiry=30)
intrinsic = max(500.0 - 400.0, 0.0)
assert price >= intrinsic, f'American put {price} should be >= intrinsic {intrinsic}'
print(f'ITM put price: {price:.2f} (intrinsic floor: {intrinsic:.2f})')
print('American pricing OK')
"
```
  </verify>
  <done>RollingTracker class exists with __init__, _scan_chain_quiet, _price_put_american, load_positions, _save_positions, and get_status methods. American put pricing applies intrinsic value floor (BS-01). scan_chain stderr is suppressed.</done>
</task>

<task type="auto">
  <name>Task 2: Add roll suggestion, position logging, and history methods</name>
  <files>src/analysis/rolling_tracker.py</files>
  <action>
Add the remaining methods to the RollingTracker class in `src/analysis/rolling_tracker.py`.

**`suggest_roll()` method:**
```python
def suggest_roll(self, max_suggestions: int = 3) -> list[dict]:
    """
    Find positions within roll window and suggest replacements.

    RT-02: Fixed 7-day DTE roll window (from context decisions -- NOT configurable).
    RT-03: Scans options chain for replacement candidates.

    Returns list of dicts, each containing:
    - position: dict (the position that needs rolling)
    - suggestions: list[dict] (top N replacement candidates)
    """
```
Implementation:
1. Load positions and calculate status via `get_status()`
2. Filter to positions where hedge_type == "put" AND dte <= 7 AND dte > 0 (not expired)
3. For each position needing a roll:
   a. Call `_scan_chain_quiet()` with the position's ticker, option_type="put", using config's min_otm_pct, max_otm_pct, target_dte_min, target_dte_max
   b. If scan returns contracts, rank them by per-day cost: `(contract.mid or contract.last_price) / contract.days_to_expiry`
   c. Take the top `max_suggestions` candidates
   d. For each candidate, build a dict with: suggested_strike, suggested_expiry, estimated_cost (mid price * 100 for per-contract total), days_to_expiry, per_day_cost, reason (auto-generated: "Lower per-day cost: ${X}/day for {Y} DTE")
4. Return list of {position, suggestions} dicts
5. If scan_chain raises an exception (e.g., no options data), catch it and return suggestions as empty list with an error note

**`log_position()` method:**
```python
def log_position(self, position_data: dict) -> dict:
    """
    Add a new position to positions.yaml.

    Args:
        position_data: Dict with HedgePosition fields plus optional metadata
            (reason, protects_layer, target_portfolio_value)

    Returns:
        The validated position dict that was saved.
    """
```
Implementation:
1. Validate core fields by constructing `HedgePosition.model_validate(position_data)` -- this ensures required fields are present and valid
2. Load current positions list
3. Append the full position_data dict (preserving metadata fields)
4. Save via `_save_positions()`
5. Return the position_data dict

**`log_roll()` method:**
```python
def log_roll(
    self,
    closed_position_index: int,
    new_position_data: dict,
) -> dict:
    """
    Record closing one position and opening another.

    Args:
        closed_position_index: Index of the position being closed (from status output)
        new_position_data: Dict with HedgePosition fields for the new position

    Returns:
        Roll record dict that was appended to roll-history.yaml.
    """
```
Implementation:
1. Load current positions
2. Validate closed_position_index is in range
3. Remove the closed position from the list
4. Validate new_position_data via HedgePosition.model_validate()
5. Add new_position_data to positions list
6. Save updated positions via `_save_positions()`
7. Create roll record: `{"date": date.today().isoformat(), "closed_position": closed_pos, "opened_position": new_position_data, "net_cost": new_cost - old_cost}`
8. Append roll record to roll-history.yaml
9. Return the roll record

**`_append_roll_history()` private helper:**
Read roll-history.yaml, append new roll record to the rolls list, write back.

**`get_history()` method:**
```python
def get_history(self) -> list[dict]:
    """Load all historical roll records from roll-history.yaml."""
    if not self.history_path.exists():
        return []
    with open(self.history_path) as f:
        data = yaml.safe_load(f) or {}
    rolls = data.get("rolls", [])
    return rolls if rolls else []
```

**Edge cases to handle:**
- Empty positions.yaml (positions key is None or missing)
- Empty roll-history.yaml (rolls key is None or missing)
- scan_chain() raising ValueError when no options data available
- Position index out of range in log_roll()
  </action>
  <verify>
```bash
uv run python -c "
from src.analysis.rolling_tracker import RollingTracker
tracker = RollingTracker()

# Test log_position
from datetime import date
pos = tracker.log_position({
    'ticker': 'QQQ',
    'hedge_type': 'put',
    'strike': 420.0,
    'expiry': '2026-04-17',
    'quantity': 2,
    'premium_paid': 8.50,
    'entry_date': '2026-02-01',
    'contract_symbol': 'QQQ260417P00420000',
})
print(f'Logged position: {pos[\"ticker\"]} {pos[\"strike\"]}')

# Verify it's in positions
positions = tracker.load_positions()
assert len(positions) >= 1, 'Should have at least 1 position'
print(f'Positions after log: {len(positions)}')

# Test get_history
history = tracker.get_history()
print(f'History records: {len(history)}')

print('All methods OK')
"
```
  </verify>
  <done>RollingTracker has suggest_roll (RT-02, RT-03), log_position, log_roll, get_history methods. Roll suggestions ranked by per-day cost with top 3 candidates. Position and roll data persisted to YAML files.</done>
</task>

</tasks>

<verification>
Full integration check:

```bash
# 1. Import and instantiate
uv run python -c "
from src.analysis.rolling_tracker import RollingTracker
tracker = RollingTracker()
print('Import OK')
"

# 2. Verify all public methods exist
uv run python -c "
from src.analysis.rolling_tracker import RollingTracker
methods = ['load_positions', 'get_status', 'suggest_roll', 'log_position', 'log_roll', 'get_history']
for m in methods:
    assert hasattr(RollingTracker, m), f'Missing method: {m}'
print(f'All {len(methods)} methods present')
"

# 3. Verify scan_chain_quiet suppresses stderr
uv run python -c "
from src.analysis.rolling_tracker import RollingTracker
tracker = RollingTracker()
assert hasattr(tracker, '_scan_chain_quiet'), 'Missing _scan_chain_quiet'
assert hasattr(tracker, '_price_put_american'), 'Missing _price_put_american'
print('Private helpers present')
"
```
</verification>

<success_criteria>
1. `src/analysis/rolling_tracker.py` exists with RollingTracker class following Layer 2 conventions
2. _scan_chain_quiet() wraps scan_chain() suppressing stderr (contextlib.redirect_stderr)
3. _price_put_american() applies max(bs_price, intrinsic_value) floor (BS-01)
4. get_status() enriches positions with DTE, current_value, P&L, urgency markers
5. suggest_roll() scans chain for replacements, ranks by per-day cost, returns top 3 (RT-02, RT-03)
6. log_position() validates via HedgePosition and persists to positions.yaml
7. log_roll() moves position, appends to roll-history.yaml
8. get_history() reads from roll-history.yaml
9. All methods handle empty/missing YAML files gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/08-rolling-tracker-hedge-sizer/08-01-SUMMARY.md`
</output>
