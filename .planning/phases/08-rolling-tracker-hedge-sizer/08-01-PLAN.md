---
phase: 08-rolling-tracker-hedge-sizer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/analysis/rolling_tracker.py
autonomous: true

must_haves:
  truths:
    - "RollingTracker loads positions from positions.yaml and enriches each with live spot price, theoretical value, P&L, DTE, and status"
    - "scan_chain_quiet() wraps scan_chain() with stderr suppressed via contextlib.redirect_stderr"
    - "suggest_rolls() identifies positions within the configurable DTE roll window and returns RollSuggestion models with replacement candidates from the options chain"
    - "log_roll() closes one position and opens another in positions.yaml, appending a record to roll-history.yaml"
    - "get_history() loads and returns roll-history.yaml entries"
    - "price_american_put() applies max(bs_price, intrinsic_value) floor for American-style put pricing"
  artifacts:
    - path: "src/analysis/rolling_tracker.py"
      provides: "RollingTracker calculator class with scan_chain_quiet, price_american_put, position enrichment, roll suggestion engine, log_roll, history"
      exports: ["RollingTracker", "scan_chain_quiet", "price_american_put"]
      min_lines: 200
  key_links:
    - from: "src/analysis/rolling_tracker.py"
      to: "src/models/hedging_inputs.py"
      via: "import HedgePosition, RollSuggestion"
      pattern: "from src\\.models\\.hedging_inputs import"
    - from: "src/analysis/rolling_tracker.py"
      to: "src/config/config_loader.py"
      via: "import load_hedge_config, HedgeConfig"
      pattern: "from src\\.config\\.config_loader import"
    - from: "src/analysis/rolling_tracker.py"
      to: "src/analysis/options_chain_cli.py"
      via: "import scan_chain, wrapped via redirect_stderr"
      pattern: "from src\\.analysis\\.options_chain_cli import scan_chain"
    - from: "src/analysis/rolling_tracker.py"
      to: "src/analysis/options.py"
      via: "import price_option for BS pricing"
      pattern: "from src\\.analysis\\.options import price_option"
    - from: "src/analysis/rolling_tracker.py"
      to: "fin-guru-private/hedging/positions.yaml"
      via: "yaml.safe_load for position loading"
      pattern: "positions\\.yaml"
---

<objective>
Build the RollingTracker calculator class (Layer 2) that manages hedge position monitoring, roll suggestions, and roll logging.

Purpose: This is the business logic layer for the rolling tracker CLI. It integrates Phase 6 models (HedgePosition, RollSuggestion) with the existing options chain scanner and Black-Scholes pricer. It also introduces the scan_chain_quiet() wrapper and American-style put pricing adjustment -- both reusable by the hedge sizer.

Output:
- `src/analysis/rolling_tracker.py` with RollingTracker class, scan_chain_quiet(), price_american_put()
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-rolling-tracker-hedge-sizer/08-RESEARCH.md

# Phase 6 deliverables (what we consume)
@.planning/phases/06-config-loader-shared-hedging-models/06-01-PLAN.md
@.planning/phases/06-config-loader-shared-hedging-models/06-02-PLAN.md

# Existing code to integrate with
@src/analysis/options_chain_cli.py
@src/analysis/options.py
@src/utils/market_data.py
@src/models/hedging_inputs.py
@src/config/config_loader.py

# Pattern references
@src/analysis/risk_metrics.py
@.planning/codebase/CONVENTIONS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create rolling_tracker.py with scan_chain_quiet, price_american_put, and YAML I/O helpers</name>
  <files>src/analysis/rolling_tracker.py</files>
  <action>
Create `src/analysis/rolling_tracker.py` following the Layer 2 calculator class pattern.

**Module docstring:**
- ARCHITECTURE NOTE: Layer 2 of 3-layer architecture
- EDUCATIONAL CONTEXT: Explain rolling options positions (what it means to "roll" a hedge), why DTE monitoring matters, and the American-style pricing limitation
- BS-01 documentation: Include a clear section explaining that Black-Scholes assumes European exercise, US equity options are American-style, and the intrinsic value floor is applied as `max(bs_price, intrinsic_value)`. This satisfies requirement BS-01.

**Imports:**
```python
import io
import math
import sys
import yaml
from contextlib import redirect_stderr
from datetime import date
from pathlib import Path

from src.analysis.options import price_option
from src.analysis.options_chain_cli import scan_chain
from src.config.config_loader import HedgeConfig, load_hedge_config
from src.models.hedging_inputs import HedgePosition, RollSuggestion
from src.utils.market_data import get_prices
```

**Constants:**
```python
PROJECT_ROOT = Path(__file__).parent.parent.parent
HEDGING_DIR = PROJECT_ROOT / "fin-guru-private" / "hedging"
DEFAULT_IV = 0.30  # Default implied volatility when actual IV unavailable
```

**Function: scan_chain_quiet()**
- Exact signature from research Pattern 3: `scan_chain_quiet(ticker, option_type, otm_min, otm_max, days_min, days_max, budget=None, target_contracts=1)`
- Wraps `scan_chain()` with `contextlib.redirect_stderr(io.StringIO())` to suppress the 12 stderr progress messages
- Returns the OptionsChainOutput result unchanged
- Add docstring explaining WHY: scan_chain() writes progress to stderr which pollutes output when called programmatically

**Function: price_american_put()**
- Signature: `price_american_put(spot, strike, days_to_expiry, volatility, risk_free_rate=0.045, dividend_yield=0.0) -> float`
- Calls `price_option()` from options.py to get BS price
- Calculates intrinsic value: `max(strike - spot, 0.0)`
- Returns `max(greeks.option_price, intrinsic_value)`
- Docstring must include BS-01 educational note about American vs European

**Class: RollingTracker**
- Constructor: `__init__(self, config: HedgeConfig | None = None)`
  - If config is None, call `load_hedge_config()` for defaults
  - Store config, HEDGING_DIR path

- Method: `load_positions(self) -> list[HedgePosition]`
  - Read `positions.yaml` from HEDGING_DIR
  - Handle missing file (return empty list), empty file (`yaml.safe_load(f) or {}`), invalid entries (warn to stderr, skip)
  - Parse each entry through `HedgePosition(**entry)` for validation
  - Return list of validated HedgePosition models

- Method: `save_positions(self, positions: list[HedgePosition]) -> None`
  - Write positions back to positions.yaml using `model_dump(mode="json")` for date serialization
  - Create HEDGING_DIR if needed

- Method: `enrich_position(self, position: HedgePosition) -> dict`
  - Calculate DTE: `(position.expiry - date.today()).days` if expiry exists, else None
  - Fetch spot price via `get_prices(position.ticker)`
  - For puts: calculate current theoretical value using `price_american_put()` with DEFAULT_IV
  - For inverse ETFs: current value is spot price from `get_prices(position.ticker)`
  - Calculate P&L: `(current_value * multiplier * quantity) - (premium_paid * multiplier * quantity)` where multiplier is 100 for puts, 1 for inverse ETFs
  - Determine status: "ROLL" if DTE is not None and `dte <= self.config.roll_window_days`, else "OK"
  - Return dict with keys: ticker, type, strike, expiry, dte, contract_symbol, entry_premium, current_value, p_and_l, quantity, status

- Method: `get_status(self) -> list[dict]`
  - Load positions, enrich each, return list of enriched dicts
  - Handle empty positions gracefully (return empty list)

- Method: `suggest_rolls(self, window_override: int | None = None) -> list[RollSuggestion]`
  - Load positions, filter to puts with DTE within roll window (use window_override if provided, else config.roll_window_days)
  - DTE check: `dte is not None and dte <= roll_window`  (inclusive, so 0 DTE is caught)
  - For each position needing roll:
    - Call `scan_chain_quiet()` with the position's ticker, "put", config OTM params, config DTE params
    - From results, pick the best replacement: closest to target DTE, within OTM range
    - Build RollSuggestion with current_position, suggested_strike, suggested_expiry, estimated_cost, reason
  - Return list of RollSuggestion models
  - If scan_chain returns empty results for a position, log warning but continue

- Method: `log_roll(self, old_symbol: str, new_symbol: str, cost: float, received: float = 0.0) -> dict`
  - Load positions, find position with matching contract_symbol (exact match)
  - If not found, raise ValueError with helpful message including expected format
  - Remove old position from positions list
  - Create new HedgePosition from the roll data (new_symbol, cost as premium_paid, today as entry_date)
    - NOTE: The new position inherits ticker and hedge_type from old. Strike and expiry must be parsed from new_symbol or provided.
    - For v1 simplicity: create the new position with the essential fields. The user can edit positions.yaml to fill in strike/expiry details. Log a note about this.
  - Save updated positions
  - Append roll record to roll-history.yaml (date, closed_position details, opened_position details, net_cost)
  - Return dict summarizing the roll

- Method: `get_history(self) -> list[dict]`
  - Read roll-history.yaml, return list of roll records
  - Handle missing/empty file gracefully

**IMPORTANT conventions (from CONVENTIONS.md):**
- Type hints on ALL parameters and returns
- Google-style docstrings with WHAT/WHY/HOW
- No circular imports (this file imports FROM models and config, never the other direction)
- Private helpers prefixed with `_`
- Use `yaml.safe_load(f) or {}` for empty YAML handling (Pitfall 5 from research)
- Educational disclaimers in module docstring
  </action>
  <verify>
Run import check:
```bash
uv run python -c "
from src.analysis.rolling_tracker import RollingTracker, scan_chain_quiet, price_american_put
print('Import OK')
"
```

Test price_american_put with known values:
```bash
uv run python -c "
from src.analysis.rolling_tracker import price_american_put
# Deep ITM put: strike 500, spot 400 -> intrinsic = 100
# BS should give something, but intrinsic floor should dominate
price = price_american_put(spot=400.0, strike=500.0, days_to_expiry=1, volatility=0.30)
assert price >= 100.0, f'American put floor not applied: got {price}'
print(f'Deep ITM put price: {price:.2f} (>= 100.0 intrinsic floor)')

# OTM put: strike 400, spot 500 -> intrinsic = 0
price2 = price_american_put(spot=500.0, strike=400.0, days_to_expiry=30, volatility=0.30)
assert price2 >= 0.0, f'OTM put should be non-negative: got {price2}'
print(f'OTM put price: {price2:.2f} (BS price, intrinsic=0)')
print('American put pricing OK')
"
```

Test RollingTracker instantiation:
```bash
uv run python -c "
from src.analysis.rolling_tracker import RollingTracker
tracker = RollingTracker()
print(f'Config budget: {tracker.config.monthly_budget}')
positions = tracker.load_positions()
print(f'Positions loaded: {len(positions)}')
history = tracker.get_history()
print(f'History loaded: {len(history)}')
print('RollingTracker instantiation OK')
"
```
  </verify>
  <done>
rolling_tracker.py exists with:
- scan_chain_quiet() wrapping scan_chain with stderr suppression
- price_american_put() with intrinsic value floor (BS-01)
- RollingTracker class with load_positions, save_positions, enrich_position, get_status, suggest_rolls, log_roll, get_history
- All methods use Phase 6 models (HedgePosition, RollSuggestion) and config (HedgeConfig)
- BS-01 documented in module docstring and price_american_put docstring
  </done>
</task>

</tasks>

<verification>
```bash
# 1. Import verification
uv run python -c "from src.analysis.rolling_tracker import RollingTracker, scan_chain_quiet, price_american_put; print('All exports importable')"

# 2. Layer 2 purity check (no argparse, no sys.exit in this file)
grep -c "argparse\|sys.exit" src/analysis/rolling_tracker.py && echo "FAIL: Layer 2 should not have CLI code" || echo "Layer 2 purity OK"

# 3. American put floor test
uv run python -c "
from src.analysis.rolling_tracker import price_american_put
p = price_american_put(spot=400.0, strike=500.0, days_to_expiry=1, volatility=0.30)
assert p >= 100.0, f'Floor not applied: {p}'
print('BS-01 intrinsic floor verified')
"

# 4. Empty positions handling
uv run python -c "
from src.analysis.rolling_tracker import RollingTracker
t = RollingTracker()
assert t.load_positions() == [] or isinstance(t.load_positions(), list)
print('Empty positions handled')
"
```
</verification>

<success_criteria>
1. RollingTracker class instantiates with default or provided HedgeConfig
2. scan_chain_quiet() calls scan_chain() with stderr suppressed (no progress messages leak)
3. price_american_put() returns max(bs_price, intrinsic_value) -- verified with deep ITM test case
4. load_positions() handles missing file, empty file, and invalid entries gracefully
5. enrich_position() returns dict with live DTE, current_value, P&L, and roll status
6. suggest_rolls() filters by DTE window and calls scan_chain_quiet for replacements
7. log_roll() removes old position, appends roll record, saves state
8. BS-01 documentation exists in module docstring
</success_criteria>

<output>
After completion, create `.planning/phases/08-rolling-tracker-hedge-sizer/08-01-SUMMARY.md`
</output>
