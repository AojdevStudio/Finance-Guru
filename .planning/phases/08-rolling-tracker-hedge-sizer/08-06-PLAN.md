---
phase: 08-rolling-tracker-hedge-sizer
plan: 06
type: execute
wave: 3
depends_on: ["08-01", "08-02", "08-03", "08-04"]
files_modified:
  - tests/python/test_rolling_tracker.py
  - tests/python/test_hedge_sizer.py
autonomous: true

must_haves:
  truths:
    - "test_rolling_tracker.py has known-answer tests for DTE calculation, American put pricing, position status, and YAML persistence"
    - "test_hedge_sizer.py has known-answer tests for contract sizing formula, allocation distribution, and budget validation"
    - "All tests use mocked market data (no live API calls in unit tests)"
    - "Tests validate edge cases: empty positions, zero DTE, over-budget, single underlying"
    - "uv run pytest tests/python/test_rolling_tracker.py tests/python/test_hedge_sizer.py passes with zero failures"
  artifacts:
    - path: "tests/python/test_rolling_tracker.py"
      provides: "Known-answer tests for RollingTracker calculator and CLI"
      contains: "class TestRollingTracker"
    - path: "tests/python/test_hedge_sizer.py"
      provides: "Known-answer tests for HedgeSizer calculator and CLI"
      contains: "class TestHedgeSizer"
  key_links:
    - from: "tests/python/test_rolling_tracker.py"
      to: "src/analysis/rolling_tracker.py"
      via: "import RollingTracker"
      pattern: "from src\\.analysis\\.rolling_tracker import"
    - from: "tests/python/test_hedge_sizer.py"
      to: "src/analysis/hedge_sizer.py"
      via: "import HedgeSizer"
      pattern: "from src\\.analysis\\.hedge_sizer import"
---

<objective>
Write comprehensive known-answer tests for both the RollingTracker and HedgeSizer calculators and their CLIs, validating correctness with hardcoded expected values and mocked market data.

Purpose: These tests ensure the core financial calculations are correct (contract sizing, DTE computation, allocation distribution, budget validation) and remain correct through future changes. Known-answer tests use hardcoded inputs and expected outputs so failures pinpoint exactly what broke. Market data is mocked to avoid test flakiness from live API calls.

Output:
- `tests/python/test_rolling_tracker.py` with 10+ tests
- `tests/python/test_hedge_sizer.py` with 10+ tests
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/codebase/TESTING.md
@.planning/phases/08-rolling-tracker-hedge-sizer/08-01-SUMMARY.md
@.planning/phases/08-rolling-tracker-hedge-sizer/08-02-SUMMARY.md

# Pattern references
@tests/python/test_risk_metrics.py
@src/analysis/rolling_tracker.py
@src/analysis/hedge_sizer.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write test_rolling_tracker.py with known-answer tests</name>
  <files>tests/python/test_rolling_tracker.py</files>
  <action>
Create `tests/python/test_rolling_tracker.py` following the test conventions from `test_risk_metrics.py`.

**Module docstring:**
```python
"""
Known-answer tests for RollingTracker calculator.

Tests validate DTE calculation, American put pricing, position loading,
status enrichment, and roll suggestion logic using mocked market data.

HEDG-13, STD-04: Tests for rolling tracker components.
"""
```

**Imports:**
```python
import pytest
import yaml
from datetime import date, timedelta
from pathlib import Path
from unittest.mock import patch, MagicMock
from pydantic import ValidationError

from src.analysis.rolling_tracker import RollingTracker
from src.models.hedging_inputs import HedgePosition
from src.config import HedgeConfig
```

**Fixtures:**

```python
@pytest.fixture
def tmp_positions_file(tmp_path):
    """Create a temporary positions.yaml with known data."""
    positions_file = tmp_path / "positions.yaml"
    positions_data = {
        "positions": [
            {
                "ticker": "QQQ",
                "hedge_type": "put",
                "strike": 420.0,
                "expiry": (date.today() + timedelta(days=5)).isoformat(),
                "quantity": 2,
                "premium_paid": 8.50,
                "entry_date": (date.today() - timedelta(days=25)).isoformat(),
                "contract_symbol": "QQQ260417P00420000",
            },
            {
                "ticker": "SPY",
                "hedge_type": "put",
                "strike": 480.0,
                "expiry": (date.today() + timedelta(days=30)).isoformat(),
                "quantity": 1,
                "premium_paid": 6.20,
                "entry_date": (date.today() - timedelta(days=10)).isoformat(),
                "contract_symbol": "SPY260417P00480000",
            },
            {
                "ticker": "SQQQ",
                "hedge_type": "inverse_etf",
                "quantity": 100,
                "premium_paid": 25.50,
                "entry_date": (date.today() - timedelta(days=15)).isoformat(),
            },
        ]
    }
    with open(positions_file, "w") as f:
        yaml.dump(positions_data, f)
    return positions_file

@pytest.fixture
def tmp_history_file(tmp_path):
    """Create a temporary empty roll-history.yaml."""
    history_file = tmp_path / "roll-history.yaml"
    with open(history_file, "w") as f:
        yaml.dump({"rolls": []}, f)
    return history_file

@pytest.fixture
def tracker(tmp_positions_file, tmp_history_file):
    """Create a RollingTracker with temp files and default config."""
    config = HedgeConfig()
    return RollingTracker(
        config=config,
        positions_path=tmp_positions_file,
        history_path=tmp_history_file,
    )
```

**Test classes:**

**class TestRollingTrackerPositionLoading:**
- `test_load_positions_returns_all`: Load 3 positions from fixture, assert len == 3
- `test_load_positions_empty_file`: Create empty YAML, load returns []
- `test_load_positions_missing_file`: Point to nonexistent file, load returns []
- `test_load_positions_validates_tickers`: All tickers should be uppercase strings

**class TestAmericanPutPricing:**
- `test_itm_put_uses_intrinsic_floor`: spot=400, strike=500 -> price >= 100 (intrinsic)
- `test_otm_put_uses_bs_price`: spot=500, strike=400 -> price > 0 but intrinsic is 0
- `test_atm_put_reasonable_value`: spot=450, strike=450, 30 DTE -> price between 5 and 30 (sanity check)

**class TestPositionStatus:**
- `test_status_enriches_with_dte`: Mock get_prices, verify DTE calculated correctly for the 5-day put
- `test_status_urgency_markers`: 5-day DTE should show "ROLL" (<=7), 30-day should show ""
- `test_status_inverse_etf_no_dte`: SQQQ position should have DTE == 0
- `test_status_pnl_calculation`: With mocked prices, verify P&L = current_value - premium_paid

Use `@patch("src.analysis.rolling_tracker.get_prices")` to mock market data.

**class TestRollSuggestion:**
- `test_suggest_roll_finds_near_expiry_positions`: Mock scan_chain_quiet, verify only the 5-day DTE position triggers suggestions
- `test_suggest_roll_empty_when_no_positions_near_expiry`: Set all positions to 30+ DTE, verify empty suggestions

**class TestPositionLogging:**
- `test_log_position_adds_to_yaml`: Log a new position, reload, verify count increased by 1
- `test_log_position_validates_fields`: Attempt to log with missing required field, should raise ValueError or ValidationError
- `test_log_roll_moves_position`: Log a roll closing index 0, verify:
  - positions count decreased by 1 (old closed) and increased by 1 (new opened) = same count
  - roll-history.yaml has 1 record

**class TestRollHistory:**
- `test_get_history_empty`: New tracker with empty history returns []
- `test_get_history_after_roll`: After log_roll, get_history returns 1 record with correct date

Mock get_prices to return predictable values:
```python
mock_prices_return = MagicMock()
mock_prices_return.__getitem__ = lambda self, key: MagicMock(price=450.0)
```
  </action>
  <verify>
```bash
uv run pytest tests/python/test_rolling_tracker.py -v
```
All tests should pass. If any fail, debug and fix the test (not the implementation -- this is Wave 3, implementation is already complete).
  </verify>
  <done>test_rolling_tracker.py has 15+ known-answer tests covering position loading, American put pricing, status enrichment, roll suggestions, position logging, and history. All tests pass with mocked market data.</done>
</task>

<task type="auto">
  <name>Task 2: Write test_hedge_sizer.py with known-answer tests</name>
  <files>tests/python/test_hedge_sizer.py</files>
  <action>
Create `tests/python/test_hedge_sizer.py` following the test conventions from `test_risk_metrics.py`.

**Module docstring:**
```python
"""
Known-answer tests for HedgeSizer calculator.

Tests validate contract sizing formula, allocation distribution, budget
validation, and portfolio auto-detection using hardcoded expected values.

HEDG-13, STD-04: Tests for hedge sizer components.
"""
```

**Imports:**
```python
import pytest
import yaml
import csv
from datetime import date
from pathlib import Path
from unittest.mock import patch, MagicMock

from src.analysis.hedge_sizer import HedgeSizer
from src.config import HedgeConfig
```

**Fixtures:**

```python
@pytest.fixture
def sizer():
    """Create a HedgeSizer with default config."""
    return HedgeSizer(config=HedgeConfig())

@pytest.fixture
def tmp_portfolio_csv(tmp_path):
    """Create a fake Portfolio_Positions CSV."""
    csv_dir = tmp_path / "notebooks" / "updates"
    csv_dir.mkdir(parents=True)
    csv_file = csv_dir / "Portfolio_Positions_Feb-04-2026.csv"
    with open(csv_file, "w", newline="") as f:
        writer = csv.writer(f)
        writer.writerow(["Account Name/Number", "Symbol", "Description", "Quantity", "Last Price", "Current Value"])
        writer.writerow(["Z12345678", "QQQ", "Invesco QQQ", "200", "480.00", "$96,000.00"])
        writer.writerow(["Z12345678", "SPY", "SPDR S&P 500", "100", "520.00", "$52,000.00"])
        writer.writerow(["Z12345678", "SCHD", "Schwab US Div", "500", "82.00", "$41,000.00"])
    return csv_dir
```

**Test classes:**

**class TestContractSizing:**
Known-answer tests with hardcoded expected values:
- `test_200k_portfolio_4_contracts`: calculate_contracts(200000) == 4
- `test_100k_portfolio_2_contracts`: calculate_contracts(100000) == 2
- `test_50k_portfolio_1_contract`: calculate_contracts(50000) == 1
- `test_49k_portfolio_1_contract_minimum`: calculate_contracts(49999) == 1
- `test_300k_portfolio_6_contracts`: calculate_contracts(300000) == 6
- `test_custom_ratio_40k`: calculate_contracts(200000, sizing_ratio=40000) == 5
- `test_small_portfolio_minimum_1`: calculate_contracts(10000) == 1

**class TestAllocationDistribution:**
Known-answer tests for multi-underlying allocation:
- `test_4_contracts_70_30_split`: allocate(4, ["QQQ", "SPY"], {"QQQ": 0.7, "SPY": 0.3}) -> QQQ=3, SPY=1 (sums to 4)
- `test_6_contracts_70_30_split`: allocate(6, ["QQQ", "SPY"], {"QQQ": 0.7, "SPY": 0.3}) -> QQQ=4, SPY=2 (sums to 6)
- `test_equal_weight_3_underlyings`: allocate(6, ["QQQ", "SPY", "IWM"]) with equal weights -> 2 each
- `test_allocation_always_sums_to_total`: For totals 1-10, verify sum always equals input
- `test_single_underlying_gets_all`: allocate(4, ["QQQ"]) -> QQQ=4

**class TestBudgetValidation:**
Tests with mocked premium fetching:
- `test_within_budget`: Mock estimate_premium to return $200/contract, 2 contracts -> $400 total, $800 budget -> 50% utilization, within_budget=True
- `test_over_budget`: Mock estimate_premium to return $500/contract, 4 contracts -> $2000, $800 budget -> 250% utilization, within_budget=False
- `test_warning_at_80_percent`: Mock for 80% utilization, verify warning string is not None
- `test_no_warning_under_80`: Mock for 60% utilization, verify warning is None

Use `@patch.object(HedgeSizer, "estimate_premium")` to mock premium fetching.

**class TestPortfolioDetection:**
- `test_detect_from_csv`: Patch PORTFOLIO_CSV_DIR to tmp_portfolio_csv fixture, verify detected value == 189000 (sum of Current Value column: 96000 + 52000 + 41000)
- `test_detect_no_csv_returns_none`: Patch to empty directory, verify returns None

**class TestSizeHedgesIntegration:**
End-to-end test with all mocks:
- `test_full_sizing_flow`: Mock get_prices and scan_chain, call size_hedges with known values, verify:
  - total_contracts matches expected
  - allocations sum correctly
  - disclaimer field is present
  - utilization_pct is calculated

Mock pattern:
```python
@patch("src.analysis.hedge_sizer.scan_chain")
@patch("src.analysis.hedge_sizer.get_prices")
def test_full_sizing_flow(self, mock_prices, mock_chain):
    mock_prices.return_value = {"QQQ": MagicMock(price=480.0)}
    mock_chain.return_value = MagicMock(contracts=[])
    # ...
```
  </action>
  <verify>
```bash
uv run pytest tests/python/test_hedge_sizer.py -v
```
All tests should pass.

Run both test files together:
```bash
uv run pytest tests/python/test_rolling_tracker.py tests/python/test_hedge_sizer.py -v
```
  </verify>
  <done>test_hedge_sizer.py has 15+ known-answer tests covering contract sizing, allocation distribution, budget validation, portfolio detection, and integration. All tests pass with mocked data.</done>
</task>

</tasks>

<verification>
Full test suite verification:

```bash
# 1. Run both new test files
uv run pytest tests/python/test_rolling_tracker.py tests/python/test_hedge_sizer.py -v

# 2. Run full test suite to ensure no regressions
uv run pytest -m "not integration" --tb=short

# 3. Verify test count
uv run python -c "
import subprocess
result = subprocess.run(
    ['uv', 'run', 'pytest', 'tests/python/test_rolling_tracker.py', 'tests/python/test_hedge_sizer.py', '--co', '-q'],
    capture_output=True, text=True
)
lines = [l for l in result.stdout.strip().split('\n') if l.strip()]
test_count = len([l for l in lines if '::' in l])
print(f'Total new tests: {test_count}')
assert test_count >= 20, f'Expected at least 20 tests, got {test_count}'
print('Test count OK')
"
```
</verification>

<success_criteria>
1. `tests/python/test_rolling_tracker.py` exists with 15+ tests covering all RollingTracker methods
2. `tests/python/test_hedge_sizer.py` exists with 15+ tests covering all HedgeSizer methods
3. All tests use mocked market data (no live API calls)
4. Known-answer tests verify hardcoded expected values: floor(200k/50k)==4, etc.
5. Edge cases tested: empty positions, zero DTE, over-budget, missing CSV, single underlying
6. `uv run pytest tests/python/test_rolling_tracker.py tests/python/test_hedge_sizer.py` passes with zero failures
7. Full test suite (`uv run pytest -m "not integration"`) passes with no regressions (HEDG-13)
</success_criteria>

<output>
After completion, create `.planning/phases/08-rolling-tracker-hedge-sizer/08-06-SUMMARY.md`
</output>
