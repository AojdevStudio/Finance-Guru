---
phase: 08-rolling-tracker-hedge-sizer
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/analysis/hedge_sizer.py
autonomous: true

must_haves:
  truths:
    - "HedgeSizer.calculate() returns contract counts using floor(portfolio_value / ratio) formula"
    - "Contract allocation splits across underlyings by weight, remainder goes to first (highest-weight) underlying"
    - "Budget validation shows total estimated cost vs monthly budget with utilization percentage"
    - "Portfolio value cascade: Fidelity CSV -> user-profile.yaml -> CLI flag"
    - "When cost exceeds budget, output warns but shows full recommendation (does NOT scale down)"
    - "Coverage ratio shows notional value vs portfolio value"
  artifacts:
    - path: "src/analysis/hedge_sizer.py"
      provides: "HedgeSizer calculator class with sizing, allocation, and budget validation"
      exports: ["HedgeSizer"]
  key_links:
    - from: "src/analysis/hedge_sizer.py"
      to: "src/models/hedging_inputs.py"
      via: "HedgeSizeRequest import"
      pattern: "from src.models.hedging_inputs import"
    - from: "src/analysis/hedge_sizer.py"
      to: "src/config/config_loader.py"
      via: "HedgeConfig import"
      pattern: "from src.config.config_loader import"
---

<objective>
Build the HedgeSizer calculator class (Layer 2) that sizes hedge contracts against a portfolio, allocates across underlyings, validates budget, and reads portfolio value from Fidelity CSV.

Purpose: This is the business logic layer for the Hedge Sizer CLI. It implements the `floor(portfolio / 50k)` sizing formula, multi-underlying allocation, budget validation with live premiums, and the portfolio value cascade.

Output: `src/analysis/hedge_sizer.py` -- a single calculator class
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/models/hedging_inputs.py
@src/config/config_loader.py
@src/models/options_inputs.py
@src/CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HedgeSizer calculator with sizing, allocation, and budget validation</name>
  <files>src/analysis/hedge_sizer.py</files>
  <action>
Create `src/analysis/hedge_sizer.py` following the established Layer 2 calculator pattern.

**Module-level helper functions:**

1. `calculate_contract_count(portfolio_value: float, ratio_per_contract: float = 50000.0) -> int`:
   - Return `math.floor(portfolio_value / ratio_per_contract)`
   - Return 0 if either value is <= 0
   - Docstring: "1 contract per $50k portfolio value (configurable). HS-01."

2. `allocate_contracts(total_contracts: int, underlying_weights: dict[str, float]) -> dict[str, int]`:
   - Sort underlyings by weight descending
   - Floor-allocate: `math.floor(total_contracts * weight)` per underlying
   - Distribute remainder to highest-weight underlyings first (LOCKED decision: "5 contracts across QQQ + SPY = 3 QQQ + 2 SPY")
   - Return dict of ticker -> contract count
   - If total_contracts is 0, return all zeros

3. `read_portfolio_value_from_csv() -> float | None`:
   - Search for latest `notebooks/updates/Balances_for_Account_*.csv` (glob, sort by mtime)
   - Parse file looking for row containing "Total account value" (case-insensitive)
   - Extract the dollar value from that row (strip $, commas)
   - Return float or None if not found / parse error
   - LOCKED decision: This is the first source in the portfolio value cascade

**HedgeSizer class:**

Constructor: `__init__(self, config: HedgeConfig)` -- stores config.

Methods:

1. `resolve_portfolio_value(self, cli_value: float | None = None) -> tuple[float, str]`:
   - Implements the portfolio value cascade (LOCKED decision):
     1. If `cli_value` is provided and > 0, return `(cli_value, "cli_flag")`
     2. Try `read_portfolio_value_from_csv()`, if not None return `(csv_value, "fidelity_csv")`
     3. Fall back to a config-based default if available, or raise ValueError("No portfolio value found")
   - Returns tuple of (value, source_label) for display

2. `calculate(self, portfolio_value: float, underlyings: list[str] | None = None, ratio: float | None = None) -> dict`:
   - Use `ratio` if provided, else default 50000.0
   - Calculate total contracts: `calculate_contract_count(portfolio_value, ratio)`
   - Determine weights: if `underlyings` provided, check config's underlying_weights for those tickers. If any requested underlying is NOT in config weights, fall back to equal weighting across requested underlyings. If `underlyings` not provided, use config's underlying_weights.
   - Allocate contracts: `allocate_contracts(total_contracts, weights)`
   - Calculate notional coverage: `total_contracts * ratio` (approximate notional value covered)
   - Calculate coverage ratio: `notional / portfolio_value * 100`
   - Return dict with:
     - `portfolio_value`: float
     - `ratio_per_contract`: float
     - `total_contracts`: int
     - `allocations`: dict[str, int] (ticker -> contracts)
     - `weights_used`: dict[str, float]
     - `notional_coverage`: float
     - `coverage_pct`: float
     - `underlyings`: list[str]

3. `validate_budget(self, allocations: dict[str, int], config: HedgeConfig) -> dict`:
   - For each underlying in allocations, estimate monthly cost:
     - Import `scan_chain_quiet` from `src.analysis.rolling_tracker` (or handle import error gracefully)
     - Call scan_chain_quiet with config OTM/DTE targets, target_contracts=1
     - Take the median premium from results as the per-contract estimate
     - Monthly cost for this underlying = contracts * median_premium * 100 (per contract is 100 shares)
     - If scan fails (API error, no results), mark as "estimate_unavailable" and skip from totals
   - Total estimated monthly cost = sum across all underlyings
   - Compare against `config.monthly_budget`
   - Calculate utilization: `total_cost / monthly_budget * 100`
   - LOCKED decision: When over budget, warn but show full recommendation ("Recommended: $720/mo, Budget: $500/mo (44% over)")
   - Return dict with:
     - `total_estimated_monthly_cost`: float
     - `monthly_budget`: float
     - `utilization_pct`: float
     - `within_budget`: bool
     - `per_underlying`: list of dicts with ticker, contracts, estimated_premium, estimated_cost
     - `budget_warning`: str | None (message if over budget)

**Important implementation notes:**
- Use `from __future__ import annotations`
- Do NOT import rolling_tracker at module level (would be circular if rolling_tracker imports hedge_sizer). Import `scan_chain_quiet` inside `validate_budget` method only.
- Actually, better: Import `scan_chain_quiet` from the same place rolling_tracker will build it -- or duplicate the 3-line wrapper inline in hedge_sizer. The simplest approach: define a local `_scan_chain_quiet` in hedge_sizer.py as well (3 lines, DRY is less important than avoiding coupling between the two calculators at Layer 2).
- Wait -- even better: extract `scan_chain_quiet` and `price_american_put` as standalone functions in a shared utility, BUT that adds a file not in scope. SIMPLEST: have hedge_sizer.py import `scan_chain` and `redirect_stderr` directly (same 3-line pattern). This avoids depending on rolling_tracker.py.
- Handle the case where `notebooks/updates/Balances_for_Account_*.csv` doesn't exist gracefully (return None)
- All methods return dicts for easy JSON serialization
- Add educational disclaimer in module docstring
  </action>
  <verify>
    Run `uv run python -c "from src.analysis.hedge_sizer import HedgeSizer, calculate_contract_count, allocate_contracts; print('imports OK')"` to verify module loads.
    Run `uv run python -c "from src.analysis.hedge_sizer import calculate_contract_count; assert calculate_contract_count(200000) == 4; assert calculate_contract_count(175000) == 3; print('sizing OK')"` to verify contract sizing.
    Run `uv run python -c "from src.analysis.hedge_sizer import allocate_contracts; r = allocate_contracts(5, {'QQQ': 0.6, 'SPY': 0.4}); print(r); assert r['QQQ'] == 3; assert r['SPY'] == 2"` to verify allocation with remainder.
    Run `uv run ruff check src/analysis/hedge_sizer.py` passes with zero errors.
  </verify>
  <done>
    HedgeSizer class exists with resolve_portfolio_value, calculate, validate_budget methods.
    calculate_contract_count implements floor(portfolio/ratio) formula correctly.
    allocate_contracts distributes contracts with remainder to highest-weight underlying.
    Portfolio value cascade reads from Fidelity CSV, config, or CLI flag.
    Module loads without errors and passes ruff linting.
  </done>
</task>

</tasks>

<verification>
- `calculate_contract_count(200000)` returns 4
- `calculate_contract_count(175000)` returns 3
- `calculate_contract_count(49999)` returns 0
- `allocate_contracts(5, {"QQQ": 0.6, "SPY": 0.4})` returns `{"QQQ": 3, "SPY": 2}`
- `allocate_contracts(4, {"QQQ": 0.5, "SPY": 0.5})` returns `{"QQQ": 2, "SPY": 2}`
- `HedgeSizer(config).calculate(200000, ["QQQ", "SPY"])` returns dict with total_contracts=4, coverage info
- `uv run ruff check src/analysis/hedge_sizer.py` exits 0
</verification>

<success_criteria>
- HedgeSizer calculator class is complete with resolve_portfolio_value, calculate, validate_budget
- Contract sizing formula is correct: floor(portfolio_value / ratio_per_contract)
- Multi-underlying allocation splits correctly with remainder to first underlying
- Portfolio value cascade implemented: Fidelity CSV -> config -> CLI flag
- Budget validation warns but does not scale down when over budget
</success_criteria>

<output>
After completion, create `.planning/phases/08-rolling-tracker-hedge-sizer/08-02-SUMMARY.md`
</output>
