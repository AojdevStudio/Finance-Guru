---
phase: 08-rolling-tracker-hedge-sizer
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/analysis/hedge_sizer.py
autonomous: true

must_haves:
  truths:
    - "calculate_contracts() returns floor(portfolio_value / sizing_ratio) contracts per underlying"
    - "allocate_underlyings() distributes contracts across multiple tickers weighted by HedgeConfig.underlying_weights"
    - "validate_budget() fetches current option premiums and compares total cost against monthly budget with 80% warning threshold"
    - "detect_portfolio_value() finds the latest Portfolio_Positions_*.csv and sums the Current Value column, or returns None if no CSV found"
    - "Output includes contract counts, estimated costs, budget utilization percentage, and educational disclaimer"
  artifacts:
    - path: "src/analysis/hedge_sizer.py"
      provides: "HedgeSizer calculator class with sizing, allocation, and budget validation"
      exports: ["HedgeSizer"]
  key_links:
    - from: "src/analysis/hedge_sizer.py"
      to: "src/models/hedging_inputs.py"
      via: "import HedgeSizeRequest"
      pattern: "from src\\.models\\.hedging_inputs import"
    - from: "src/analysis/hedge_sizer.py"
      to: "src/config/config_loader.py"
      via: "import load_hedge_config, HedgeConfig"
      pattern: "from src\\.config import"
    - from: "src/analysis/hedge_sizer.py"
      to: "src/analysis/options_chain_cli.py"
      via: "scan_chain for live premium fetching"
      pattern: "from src\\.analysis\\.options_chain_cli import scan_chain"
    - from: "src/analysis/hedge_sizer.py"
      to: "fin-guru-private/hedging/budget-tracker.yaml"
      via: "yaml read/write for budget tracking"
      pattern: "budget-tracker\\.yaml"
---

<objective>
Create the HedgeSizer calculator class (Layer 2) that computes contract counts, distributes across underlyings by weight, validates against monthly budget, and auto-detects portfolio value from Fidelity CSV exports.

Purpose: This calculator implements the hedge sizing formula (1 contract per $50k portfolio value by default), handles multi-underlying allocation with configurable weights, and validates that the total hedge cost fits within the monthly budget. It auto-detects portfolio value from the latest Fidelity CSV export when available.

Output: `src/analysis/hedge_sizer.py` with a HedgeSizer class.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-rolling-tracker-hedge-sizer/08-RESEARCH.md
@.planning/phases/08-rolling-tracker-hedge-sizer/08-CONTEXT.md

# Pattern references
@src/analysis/risk_metrics.py
@src/models/hedging_inputs.py
@src/config/config_loader.py
@fin-guru-private/hedging/budget-tracker.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HedgeSizer class with contract sizing and multi-underlying allocation</name>
  <files>src/analysis/hedge_sizer.py</files>
  <action>
Create `src/analysis/hedge_sizer.py` following the Layer 2 calculator conventions from `risk_metrics.py`.

**Module docstring:** Include ARCHITECTURE NOTE (Layer 2 of 3), EDUCATIONAL CONTEXT explaining hedge sizing (insurance analogy: contracts per $50k like coverage per unit of exposure), multi-underlying diversification, and budget discipline.

**Imports:**
```python
import math
import csv
import io
import contextlib
from datetime import date
from pathlib import Path
from typing import Any

import yaml

from src.models.hedging_inputs import HedgeSizeRequest
from src.config import HedgeConfig, load_hedge_config
from src.analysis.options_chain_cli import scan_chain
from src.utils.market_data import get_prices
```

**Constants:**
```python
PROJECT_ROOT = Path(__file__).parent.parent.parent
BUDGET_TRACKER_PATH = PROJECT_ROOT / "fin-guru-private" / "hedging" / "budget-tracker.yaml"
PORTFOLIO_CSV_DIR = PROJECT_ROOT / "notebooks" / "updates"
DEFAULT_SIZING_RATIO = 50_000  # $50k per contract
```

**HedgeSizer class:**

Constructor `__init__(self, config: HedgeConfig | None = None, sizing_ratio: float | None = None)`:
- If config is None, call `load_hedge_config()` to get defaults
- Store sizing_ratio (default DEFAULT_SIZING_RATIO, overridable via constructor or --ratio CLI flag)
- Store config as self.config

**`detect_portfolio_value()` method:**
```python
def detect_portfolio_value(self) -> float | None:
    """
    Auto-detect portfolio value from latest Fidelity CSV export.

    Scans notebooks/updates/ for Portfolio_Positions_*.csv files,
    selects the most recent by filename date, and sums the
    'Current Value' column.

    Returns:
        Total portfolio value in dollars, or None if no CSV found.
    """
```
Implementation:
1. Glob for `Portfolio_Positions_*.csv` in PORTFOLIO_CSV_DIR
2. If no files found, return None
3. Sort by filename (which contains date) to get the latest
4. Open the CSV and sum the "Current Value" column
5. Handle edge cases: missing column, non-numeric values, empty file
6. Return the total as a float

**`calculate_contracts()` method:**
```python
def calculate_contracts(
    self,
    portfolio_value: float,
    sizing_ratio: float | None = None,
) -> int:
    """
    Calculate number of hedge contracts for a given portfolio value.

    HS-01: Formula is floor(portfolio_value / sizing_ratio).
    Default ratio is 1 contract per $50,000 (configurable).

    Args:
        portfolio_value: Total portfolio value in dollars
        sizing_ratio: Override for per-contract coverage amount

    Returns:
        Number of contracts (minimum 1 if portfolio_value > 0)

    EDUCATIONAL NOTE:
    This formula treats protective puts like insurance:
    each contract covers ~$50k of portfolio exposure.
    A $200k portfolio gets 4 contracts of protection.
    """
    ratio = sizing_ratio or self.sizing_ratio
    contracts = math.floor(portfolio_value / ratio)
    return max(contracts, 1)  # At least 1 contract if portfolio has value
```

**`allocate_underlyings()` method:**
```python
def allocate_underlyings(
    self,
    total_contracts: int,
    underlyings: list[str],
    weights: dict[str, float] | None = None,
) -> dict[str, int]:
    """
    Distribute contracts across multiple underlyings by weight.

    HS-03: Multi-underlying allocation weighted by portfolio exposure.
    If no weights provided, uses HedgeConfig.underlying_weights.
    If underlying not in weights dict, falls back to equal weighting.

    Args:
        total_contracts: Total contracts to distribute
        underlyings: List of ticker symbols
        weights: Optional weight overrides (must sum to ~1.0)

    Returns:
        Dict mapping ticker to contract count, e.g. {"QQQ": 3, "SPY": 1}
    """
```
Implementation:
1. Resolve weights: use provided weights, fall back to config weights, fall back to equal weighting
2. Normalize weights for the requested underlyings only (filter to underlyings list, re-normalize to sum=1.0)
3. Distribute contracts: `round(total_contracts * weight)` for each underlying
4. Ensure total allocated equals total_contracts (adjust largest allocation if rounding causes mismatch)
5. Ensure each underlying gets at least 1 contract if total_contracts >= len(underlyings)

**`__all__` at bottom:**
```python
__all__ = ["HedgeSizer"]
```
  </action>
  <verify>
```bash
uv run python -c "
from src.analysis.hedge_sizer import HedgeSizer
sizer = HedgeSizer()

# Test contract calculation
contracts = sizer.calculate_contracts(200000)
assert contracts == 4, f'Expected 4 contracts for 200k, got {contracts}'
print(f'200k portfolio -> {contracts} contracts')

contracts_small = sizer.calculate_contracts(30000)
assert contracts_small == 1, f'Expected 1 contract minimum, got {contracts_small}'
print(f'30k portfolio -> {contracts_small} contract (minimum)')

# Test allocation
alloc = sizer.allocate_underlyings(4, ['QQQ', 'SPY'], weights={'QQQ': 0.7, 'SPY': 0.3})
assert sum(alloc.values()) == 4, f'Allocation should sum to 4, got {sum(alloc.values())}'
print(f'Allocation: {alloc}')

# Test portfolio detection (may return None if no CSV)
pv = sizer.detect_portfolio_value()
print(f'Auto-detected portfolio value: {pv}')

print('HedgeSizer core OK')
"
```
  </verify>
  <done>HedgeSizer class exists with calculate_contracts (HS-01), allocate_underlyings (HS-03), and detect_portfolio_value methods. Contract sizing uses floor(value/ratio) with minimum 1. Allocation distributes by weights with rounding adjustment.</done>
</task>

<task type="auto">
  <name>Task 2: Add budget validation with live premiums and budget tracker integration</name>
  <files>src/analysis/hedge_sizer.py</files>
  <action>
Add budget validation and premium estimation methods to the HedgeSizer class.

**`estimate_premium()` method:**
```python
def estimate_premium(
    self,
    ticker: str,
    contracts: int,
) -> dict:
    """
    Fetch current option premiums for a ticker and estimate total cost.

    Uses scan_chain (with stderr suppressed) to get current put prices
    in the configured OTM and DTE range.

    Args:
        ticker: Underlying ticker symbol
        contracts: Number of contracts to price

    Returns:
        Dict with: ticker, contracts, per_contract_cost, total_cost,
        strike, expiry, source ("live_chain" or "estimate")
    """
```
Implementation:
1. Use contextlib.redirect_stderr to suppress scan_chain stderr
2. Call scan_chain with ticker, option_type="put", config's min/max OTM and DTE
3. If contracts found, pick the one closest to the midpoint of OTM range
4. Calculate per_contract_cost = mid_price * 100 (or last_price if mid unavailable)
5. total_cost = per_contract_cost * contracts
6. If scan_chain fails or returns no contracts, return estimate based on 2% of spot price as fallback, with source="estimate" and a warning

**`validate_budget()` method:**
```python
def validate_budget(
    self,
    allocations: dict[str, int],
    monthly_budget: float | None = None,
) -> dict:
    """
    Validate total hedge cost against monthly budget.

    HS-02: Compare cost against monthly budget, show utilization %.
    Warning at 80% utilization per context decisions.

    Args:
        allocations: Dict of ticker -> contract count
        monthly_budget: Override budget (default from config)

    Returns:
        Dict with: total_cost, budget, utilization_pct, warning (str|None),
        within_budget (bool), per_underlying (list of premium dicts)
    """
```
Implementation:
1. Resolve monthly_budget from arg or config
2. For each underlying in allocations, call `estimate_premium(ticker, contracts)`
3. Sum total_cost across all underlyings
4. Calculate utilization_pct = (total_cost / monthly_budget) * 100
5. Set warning:
   - If utilization_pct >= 100: "OVER BUDGET: ${total_cost:.0f} exceeds ${budget:.0f} monthly limit"
   - If utilization_pct >= 80: "WARNING: ${total_cost:.0f} is {pct:.0f}% of ${budget:.0f} monthly budget"
   - Otherwise: None
6. Load budget-tracker.yaml if exists, check current_month spend
7. Return complete dict

**`size_hedges()` method (convenience method combining all steps):**
```python
def size_hedges(
    self,
    portfolio_value: float | None = None,
    underlyings: list[str] | None = None,
    sizing_ratio: float | None = None,
    monthly_budget: float | None = None,
) -> dict:
    """
    Complete hedge sizing: calculate contracts, allocate, validate budget.

    This is the main entry point combining calculate_contracts,
    allocate_underlyings, and validate_budget into one call.

    Args:
        portfolio_value: Total portfolio value (auto-detects if None)
        underlyings: Tickers to hedge against (default from config)
        sizing_ratio: Override per-contract ratio
        monthly_budget: Override monthly budget

    Returns:
        Complete sizing result with contracts, allocations, budget validation,
        and educational disclaimer.
    """
```
Implementation:
1. Resolve portfolio_value: use arg, or auto-detect, or raise ValueError
2. Resolve underlyings: use arg, or extract from config underlying_weights keys
3. Calculate total contracts
4. Allocate across underlyings
5. Validate budget
6. Build result dict with all details plus disclaimer:
   "EDUCATIONAL NOTE: This is a sizing estimate, not investment advice. Actual premiums may differ. Consult with a financial professional before executing trades."
7. Return result dict
  </action>
  <verify>
```bash
uv run python -c "
from src.analysis.hedge_sizer import HedgeSizer
sizer = HedgeSizer()

# Test validate_budget with known allocations (will use estimates if no live data)
result = sizer.validate_budget({'QQQ': 3, 'SPY': 1}, monthly_budget=800.0)
print(f'Total cost estimate: \${result[\"total_cost\"]:.0f}')
print(f'Utilization: {result[\"utilization_pct\"]:.0f}%')
print(f'Warning: {result.get(\"warning\", \"None\")}')
print(f'Within budget: {result[\"within_budget\"]}')

# Test full size_hedges flow
full = sizer.size_hedges(
    portfolio_value=200000,
    underlyings=['QQQ', 'SPY'],
    monthly_budget=800.0,
)
print(f'Portfolio: \${full[\"portfolio_value\"]:,.0f}')
print(f'Total contracts: {full[\"total_contracts\"]}')
print(f'Allocations: {full[\"allocations\"]}')
assert 'disclaimer' in full, 'Missing disclaimer'
print('Budget validation OK')
"
```
  </verify>
  <done>HedgeSizer has estimate_premium (live chain scan with fallback), validate_budget (HS-02 with 80% warning), and size_hedges (convenience combining all steps). Budget utilization shown as percentage. Educational disclaimer included.</done>
</task>

</tasks>

<verification>
Full integration check:

```bash
# 1. Import and verify all methods
uv run python -c "
from src.analysis.hedge_sizer import HedgeSizer
methods = ['calculate_contracts', 'allocate_underlyings', 'detect_portfolio_value', 'estimate_premium', 'validate_budget', 'size_hedges']
for m in methods:
    assert hasattr(HedgeSizer, m), f'Missing: {m}'
print(f'All {len(methods)} methods present')
"

# 2. Known-answer contract sizing
uv run python -c "
from src.analysis.hedge_sizer import HedgeSizer
sizer = HedgeSizer()
assert sizer.calculate_contracts(200000) == 4
assert sizer.calculate_contracts(250000) == 5
assert sizer.calculate_contracts(49999) == 1  # minimum 1
assert sizer.calculate_contracts(50000) == 1
assert sizer.calculate_contracts(100000) == 2
print('Known-answer sizing: all correct')
"

# 3. Allocation sums correctly
uv run python -c "
from src.analysis.hedge_sizer import HedgeSizer
sizer = HedgeSizer()
for total in [4, 5, 6, 10]:
    alloc = sizer.allocate_underlyings(total, ['QQQ', 'SPY'], weights={'QQQ': 0.7, 'SPY': 0.3})
    assert sum(alloc.values()) == total, f'Sum mismatch for {total}: {alloc}'
print('Allocation sums verified for 4, 5, 6, 10 contracts')
"
```
</verification>

<success_criteria>
1. `src/analysis/hedge_sizer.py` exists with HedgeSizer class following Layer 2 conventions
2. calculate_contracts() uses floor(value/ratio) with minimum 1 (HS-01)
3. allocate_underlyings() distributes by weights with rounding adjustment (HS-03)
4. detect_portfolio_value() finds latest Portfolio_Positions_*.csv and sums Current Value
5. estimate_premium() fetches live premiums via scan_chain with fallback estimate
6. validate_budget() shows utilization %, warns at 80% (HS-02)
7. size_hedges() combines all steps into one convenience call
8. Educational disclaimer included in output (XC-05)
</success_criteria>

<output>
After completion, create `.planning/phases/08-rolling-tracker-hedge-sizer/08-02-SUMMARY.md`
</output>
