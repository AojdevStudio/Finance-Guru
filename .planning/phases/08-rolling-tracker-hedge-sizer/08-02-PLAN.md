---
phase: 08-rolling-tracker-hedge-sizer
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/analysis/hedge_sizer.py
autonomous: true

must_haves:
  truths:
    - "calculate_contract_count() returns floor(portfolio_value / ratio_per_contract) with configurable ratio"
    - "allocate_contracts() distributes contracts across underlyings by weight, with remainder to largest weight"
    - "validate_budget() fetches current put premiums via scan_chain_quiet and compares total cost against monthly budget"
    - "HedgeSizer.size() returns a complete sizing result with contract allocations, estimated costs, and budget utilization percentage"
    - "Budget tracker auto-resets spent_this_month when current_month differs from today's month"
  artifacts:
    - path: "src/analysis/hedge_sizer.py"
      provides: "HedgeSizer calculator class with contract sizing, allocation, budget validation"
      exports: ["HedgeSizer", "calculate_contract_count", "allocate_contracts"]
      min_lines: 150
  key_links:
    - from: "src/analysis/hedge_sizer.py"
      to: "src/models/hedging_inputs.py"
      via: "import HedgeSizeRequest"
      pattern: "from src\\.models\\.hedging_inputs import"
    - from: "src/analysis/hedge_sizer.py"
      to: "src/config/config_loader.py"
      via: "import load_hedge_config, HedgeConfig"
      pattern: "from src\\.config\\.config_loader import"
    - from: "src/analysis/hedge_sizer.py"
      to: "src/analysis/rolling_tracker.py"
      via: "import scan_chain_quiet for premium estimation"
      pattern: "from src\\.analysis\\.rolling_tracker import scan_chain_quiet"
    - from: "src/analysis/hedge_sizer.py"
      to: "fin-guru-private/hedging/budget-tracker.yaml"
      via: "yaml read/write for budget tracking"
      pattern: "budget-tracker\\.yaml"
---

<objective>
Build the HedgeSizer calculator class (Layer 2) that sizes hedge contracts, allocates across underlyings, and validates against the monthly budget.

Purpose: This is the business logic for the hedge sizer CLI. It implements the floor(portfolio_value / 50000) sizing formula (HS-01), multi-underlying allocation with configurable weights (HS-03), and budget validation with live premium estimation (HS-02). It reuses scan_chain_quiet() from the rolling tracker for premium fetching.

Output:
- `src/analysis/hedge_sizer.py` with HedgeSizer class, calculate_contract_count(), allocate_contracts()
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-rolling-tracker-hedge-sizer/08-RESEARCH.md

# Phase 6 deliverables
@.planning/phases/06-config-loader-shared-hedging-models/06-01-PLAN.md
@.planning/phases/06-config-loader-shared-hedging-models/06-02-PLAN.md

# Reuse from Plan 01 (parallel -- scan_chain_quiet is a standalone function)
@src/analysis/rolling_tracker.py

# Existing code
@src/models/hedging_inputs.py
@src/config/config_loader.py

# Pattern reference
@src/analysis/risk_metrics.py
@.planning/codebase/CONVENTIONS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create hedge_sizer.py with sizing formula, allocation, and budget validation</name>
  <files>src/analysis/hedge_sizer.py</files>
  <action>
Create `src/analysis/hedge_sizer.py` following the Layer 2 calculator class pattern.

**Module docstring:**
- ARCHITECTURE NOTE: Layer 2 of 3-layer architecture
- EDUCATIONAL CONTEXT: Explain hedge sizing concepts -- why 1 put contract per $50k is a reasonable baseline (1 contract = 100 shares, typical put for a ~$500 underlying covers ~$50k notional), how multi-underlying diversification reduces single-asset hedge risk, and why budget validation prevents over-allocation

**Imports:**
```python
import math
import yaml
from datetime import date
from pathlib import Path

from src.config.config_loader import HedgeConfig, load_hedge_config
from src.models.hedging_inputs import HedgeSizeRequest
```

NOTE: Do NOT import `scan_chain_quiet` at module level. It must be a lazy import inside `validate_budget()` to avoid circular issues if rolling_tracker is not yet built. The exact pattern inside `validate_budget` must be:

```python
def validate_budget(self, allocation: dict[str, int]) -> dict:
    """Validate allocation cost against monthly hedge budget (HS-02).

    Uses lazy import of scan_chain_quiet to avoid circular dependency
    with rolling_tracker.py (both are Wave 1, built in parallel).
    """
    from src.analysis.rolling_tracker import scan_chain_quiet

    per_underlying = []
    for ticker, contracts in allocation.items():
        # Call scan_chain_quiet with config OTM/DTE params
        result = scan_chain_quiet(
            ticker=ticker,
            option_type="put",
            otm_min=self.config.min_otm_pct,
            otm_max=self.config.max_otm_pct,
            days_min=self.config.target_dte_min,
            days_max=self.config.target_dte_max,
        )
        # ... extract median premium, calculate cost ...
```

This lazy import is CRITICAL -- it is the key link between hedge_sizer.py and rolling_tracker.py. The `from src.analysis.rolling_tracker import scan_chain_quiet` line must appear inside the method body, not at file top.

**Constants:**
```python
PROJECT_ROOT = Path(__file__).parent.parent.parent
HEDGING_DIR = PROJECT_ROOT / "fin-guru-private" / "hedging"
DEFAULT_RATIO_PER_CONTRACT = 50_000.0
```

**Standalone function: calculate_contract_count()**
- Signature: `calculate_contract_count(portfolio_value: float, ratio_per_contract: float = DEFAULT_RATIO_PER_CONTRACT) -> int`
- Formula: `math.floor(portfolio_value / ratio_per_contract)`
- Handle edge cases: return 0 if portfolio_value <= 0 or ratio_per_contract <= 0
- Docstring: Explain the formula and the $50k default ratio
- This is a pure function, no side effects

**Standalone function: allocate_contracts()**
- Signature: `allocate_contracts(total_contracts: int, underlying_weights: dict[str, float]) -> dict[str, int]`
- Sort underlyings by weight descending
- Allocate `math.floor(total_contracts * weight)` to each
- Distribute remainder (total - sum of allocated) one at a time to highest-weight underlyings
- Handle edge case: total_contracts = 0 returns all zeros
- Handle edge case: single underlying gets all contracts
- Docstring with example: 4 contracts, {"QQQ": 0.6, "SPY": 0.4} -> {"QQQ": 3, "SPY": 1}

**Class: HedgeSizer**
- Constructor: `__init__(self, config: HedgeConfig | None = None)`
  - If config is None, call `load_hedge_config()` for defaults
  - Store config, HEDGING_DIR path

- Method: `size(self, request: HedgeSizeRequest) -> dict`
  - Main entry point. Takes a HedgeSizeRequest model.
  - Calculate total contracts: if request.target_contracts is not None, use it; else call `calculate_contract_count(request.portfolio_value)`
  - Determine underlying weights: from config.underlying_weights, filtered to only the underlyings in request.underlyings. If any requested underlying is NOT in config weights, fall back to equal weighting for all requested underlyings.
  - Call `allocate_contracts(total_contracts, weights)`
  - Return dict with:
    - portfolio_value: float
    - total_contracts: int
    - allocation: dict[str, int]
    - weights_used: dict[str, float]
    - ratio_per_contract: DEFAULT_RATIO_PER_CONTRACT

- Method: `validate_budget(self, allocation: dict[str, int]) -> dict`
  - Uses lazy import of scan_chain_quiet (see code pattern above)
  - For each underlying in allocation, call `scan_chain_quiet()` to get current put premiums
    - Use config's OTM params (min_otm_pct, max_otm_pct) and DTE params (target_dte_min, target_dte_max)
    - From results, take the median premium (mid-price) as the estimate. If no results, use 0.0 and flag as unavailable.
  - Calculate per-underlying cost: `contracts * median_premium * 100` (100 shares per contract)
  - Calculate total_estimated_cost: sum of all per-underlying costs
  - Load budget-tracker.yaml to get monthly_limit and spent_this_month
    - **Auto-reset logic:** If budget_tracker's current_month differs from today's month (format "YYYY-MM"), reset spent_this_month to 0.0, set remaining to monthly_limit, archive previous month to history list
  - remaining_budget = monthly_limit - spent_this_month
  - utilization_pct = (total_estimated_cost / monthly_limit) * 100 if monthly_limit > 0 else 0
  - within_budget: total_estimated_cost <= remaining_budget
  - Return dict with:
    - total_estimated_cost: float
    - monthly_budget: float (from budget tracker)
    - spent_this_month: float
    - remaining_budget: float
    - utilization_pct: float
    - within_budget: bool
    - per_underlying: list of dicts with {ticker, contracts, estimated_premium, estimated_cost}
    - estimate_note: "Estimated cost based on current mid-price. Actual premium may differ. Verify before executing trade."

- Method: `_load_budget_tracker(self) -> dict`
  - Read budget-tracker.yaml
  - Handle missing/empty file with defaults (monthly_limit from config.monthly_budget, current_month today, spent 0)
  - Implement month auto-reset logic

- Method: `_save_budget_tracker(self, tracker: dict) -> None`
  - Write budget-tracker.yaml back

**IMPORTANT:**
- Use `yaml.safe_load(f) or {}` for empty YAML handling
- Do NOT hardcode $50,000 -- use DEFAULT_RATIO_PER_CONTRACT constant (anti-pattern from research)
- Do NOT create argparse subcommands in sizer -- it is a single operation (anti-pattern from research)
- All prices from scan_chain_quiet are point-in-time estimates -- label clearly
  </action>
  <verify>
Run import check:
```bash
uv run python -c "
from src.analysis.hedge_sizer import HedgeSizer, calculate_contract_count, allocate_contracts
print('Import OK')
"
```

Test sizing formula:
```bash
uv run python -c "
from src.analysis.hedge_sizer import calculate_contract_count, allocate_contracts

# Basic sizing
assert calculate_contract_count(200000) == 4, '\$200k / \$50k = 4'
assert calculate_contract_count(175000) == 3, '\$175k / \$50k = 3 (floor)'
assert calculate_contract_count(49999) == 0, 'Under \$50k = 0'
assert calculate_contract_count(0) == 0, 'Zero portfolio = 0'
assert calculate_contract_count(-100000) == 0, 'Negative = 0'
print('Contract count formula OK')

# Allocation
alloc = allocate_contracts(4, {'QQQ': 0.6, 'SPY': 0.4})
assert alloc['QQQ'] + alloc['SPY'] == 4, f'Total should be 4: {alloc}'
assert alloc['QQQ'] >= alloc['SPY'], f'QQQ should get more: {alloc}'
print(f'Allocation: {alloc}')

# Edge: single underlying
alloc2 = allocate_contracts(5, {'QQQ': 1.0})
assert alloc2['QQQ'] == 5
print('Single underlying allocation OK')

# Edge: zero contracts
alloc3 = allocate_contracts(0, {'QQQ': 0.6, 'SPY': 0.4})
assert all(v == 0 for v in alloc3.values())
print('Zero contracts handled')

print('All sizing tests passed')
"
```

Test HedgeSizer instantiation:
```bash
uv run python -c "
from src.analysis.hedge_sizer import HedgeSizer
from src.models.hedging_inputs import HedgeSizeRequest
sizer = HedgeSizer()
print(f'Config budget: {sizer.config.monthly_budget}')

# Test size without live data
request = HedgeSizeRequest(portfolio_value=200000.0, underlyings=['QQQ', 'SPY'], budget=500.0)
result = sizer.size(request)
print(f'Total contracts: {result[\"total_contracts\"]}')
print(f'Allocation: {result[\"allocation\"]}')
assert result['total_contracts'] == 4
print('HedgeSizer.size() OK')
"
```

Verify scan_chain_quiet is importable from rolling_tracker (confirms key link):
```bash
uv run python -c "
from src.analysis.rolling_tracker import scan_chain_quiet
assert callable(scan_chain_quiet), 'scan_chain_quiet must be callable'
print(f'scan_chain_quiet importable and callable: {scan_chain_quiet.__name__}')
"
```

Test validate_budget with mocked scan_chain_quiet (HS-02 core requirement):
```bash
uv run python -c "
import tempfile, os, yaml
from unittest.mock import patch, MagicMock

from src.analysis.hedge_sizer import HedgeSizer

sizer = HedgeSizer()

# Create a temporary budget-tracker.yaml with known values
budget_dir = sizer._hedging_dir if hasattr(sizer, '_hedging_dir') else sizer.hedging_dir if hasattr(sizer, 'hedging_dir') else None
# Use a temp dir to avoid touching real budget file
import types
from datetime import date

with tempfile.TemporaryDirectory() as tmpdir:
    # Point sizer at temp directory for budget tracker
    # Patch the HEDGING_DIR or the internal path attribute
    from pathlib import Path
    original_dir = None
    for attr in ['_hedging_dir', 'hedging_dir', '_budget_dir']:
        if hasattr(sizer, attr):
            original_dir = getattr(sizer, attr)
            setattr(sizer, attr, Path(tmpdir))
            break

    # If no known attribute, patch at module level
    if original_dir is None:
        import src.analysis.hedge_sizer as hs_mod
        original_hedging = hs_mod.HEDGING_DIR
        hs_mod.HEDGING_DIR = Path(tmpdir)

    # Write a budget tracker with known state
    budget_file = Path(tmpdir) / 'budget-tracker.yaml'
    budget_data = {
        'monthly_limit': 1000.0,
        'current_month': date.today().strftime('%Y-%m'),
        'spent_this_month': 200.0,
        'history': []
    }
    with open(budget_file, 'w') as f:
        yaml.dump(budget_data, f)

    # Mock scan_chain_quiet to return a fake result with known premiums
    mock_result = MagicMock()
    # scan_chain returns an object; we need to simulate the premium data
    # The exact structure depends on OptionsChainOutput -- mock the iteration
    mock_option = MagicMock()
    mock_option.mid_price = 5.50  # \$5.50 per share premium
    mock_option.bid = 5.00
    mock_option.ask = 6.00
    mock_result.options = [mock_option]
    mock_result.__iter__ = lambda self: iter([mock_option])
    mock_result.__len__ = lambda self: 1

    with patch('src.analysis.hedge_sizer.scan_chain_quiet', return_value=mock_result) as mock_scq:
        # 2 QQQ contracts, 1 SPY contract
        result = sizer.validate_budget({'QQQ': 2, 'SPY': 1})

        # scan_chain_quiet should have been called for each underlying
        assert mock_scq.call_count == 2, f'Expected 2 calls to scan_chain_quiet, got {mock_scq.call_count}'

        # Verify budget utilization fields exist
        assert 'total_estimated_cost' in result, 'Missing total_estimated_cost'
        assert 'utilization_pct' in result, 'Missing utilization_pct'
        assert 'within_budget' in result, 'Missing within_budget'
        assert 'remaining_budget' in result, 'Missing remaining_budget'
        assert 'per_underlying' in result, 'Missing per_underlying'

        # With 5.50 premium: QQQ cost = 2 * 5.50 * 100 = 1100, SPY = 1 * 5.50 * 100 = 550
        # Total = 1650 (or similar depending on median calc)
        # Budget: 1000 limit - 200 spent = 800 remaining
        # So within_budget should be False (1650 > 800)
        print(f'Total estimated cost: {result[\"total_estimated_cost\"]}')
        print(f'Utilization pct: {result[\"utilization_pct\"]}')
        print(f'Within budget: {result[\"within_budget\"]}')
        print(f'Remaining budget: {result[\"remaining_budget\"]}')
        print(f'Per-underlying count: {len(result[\"per_underlying\"])}')
        print('validate_budget() HS-02 verification OK')

    # Restore
    if original_dir is not None:
        for attr in ['_hedging_dir', 'hedging_dir', '_budget_dir']:
            if hasattr(sizer, attr):
                setattr(sizer, attr, original_dir)
                break
    else:
        hs_mod.HEDGING_DIR = original_hedging
"
```

Verify lazy import pattern exists in source (not at module level):
```bash
grep -n "from src.analysis.rolling_tracker import scan_chain_quiet" src/analysis/hedge_sizer.py | while read line; do
  lineno=$(echo "$line" | cut -d: -f1)
  echo "scan_chain_quiet import found at line $lineno"
done
# Confirm it is NOT in the top-level imports (should be inside a method, roughly line 50+)
```
  </verify>
  <done>
hedge_sizer.py exists with:
- calculate_contract_count() using floor(value/ratio) formula (HS-01)
- allocate_contracts() with weighted distribution and remainder handling (HS-03)
- HedgeSizer class with size() for contract sizing and validate_budget() for budget checking (HS-02)
- validate_budget() uses lazy import of scan_chain_quiet inside method body (not module-level)
- validate_budget() calls scan_chain_quiet for each underlying, computes budget utilization percentage
- Budget tracker auto-reset on month change
- scan_chain_quiet integration verified via mock test confirming call count, return structure, and budget math
  </done>
</task>

</tasks>

<verification>
```bash
# 1. Import verification
uv run python -c "from src.analysis.hedge_sizer import HedgeSizer, calculate_contract_count, allocate_contracts; print('All exports importable')"

# 2. Layer 2 purity check
grep -c "argparse\|sys.exit" src/analysis/hedge_sizer.py && echo "FAIL: Layer 2 should not have CLI code" || echo "Layer 2 purity OK"

# 3. Known-answer sizing
uv run python -c "
from src.analysis.hedge_sizer import calculate_contract_count
assert calculate_contract_count(200000) == 4
assert calculate_contract_count(50000) == 1
assert calculate_contract_count(49999) == 0
print('Sizing formula verified')
"

# 4. Known-answer allocation
uv run python -c "
from src.analysis.hedge_sizer import allocate_contracts
a = allocate_contracts(4, {'QQQ': 0.6, 'SPY': 0.4})
assert sum(a.values()) == 4
print(f'Allocation verified: {a}')
"

# 5. scan_chain_quiet key link verification
uv run python -c "from src.analysis.rolling_tracker import scan_chain_quiet; print(f'Key link OK: {scan_chain_quiet.__name__}')"

# 6. Lazy import pattern verification (import inside method, not at top)
grep -n "from src.analysis.rolling_tracker import scan_chain_quiet" src/analysis/hedge_sizer.py
```
</verification>

<success_criteria>
1. calculate_contract_count(200000) returns 4; calculate_contract_count(49999) returns 0
2. allocate_contracts distributes correctly with remainder to highest weight
3. HedgeSizer.size() returns portfolio_value, total_contracts, allocation, weights_used
4. validate_budget() fetches premiums via scan_chain_quiet and reports utilization_pct
5. validate_budget() uses lazy import of scan_chain_quiet inside method body (verified by grep and mock test)
6. scan_chain_quiet is importable from rolling_tracker and callable
7. Budget tracker auto-resets on new month
8. No argparse or CLI code in this Layer 2 file
</success_criteria>

<output>
After completion, create `.planning/phases/08-rolling-tracker-hedge-sizer/08-02-SUMMARY.md`
</output>
