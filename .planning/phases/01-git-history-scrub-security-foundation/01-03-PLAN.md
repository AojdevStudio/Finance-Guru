---
phase: 01-git-history-scrub-security-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - .gitleaks.toml
  - .pre-commit-config.yaml
  - .github/workflows/pii-check.yml
  - scripts/qa/pii-audit.sh
autonomous: true

must_haves:
  truths:
    - "A pre-commit hook blocks any commit containing known PII patterns (account numbers, API keys, personal identifiers)"
    - "Pushing to the repo triggers a CI workflow that scans working tree and git history for PII patterns and fails if any are found"
    - "Running `scripts/qa/pii-audit.sh` locally produces a PASS/FAIL report for all known PII patterns"
    - "The gitleaks config includes custom rules specific to this repo's PII patterns, not just generic secret detection"
  artifacts:
    - path: ".gitleaks.toml"
      provides: "Custom PII detection rules for gitleaks"
      contains: "fidelity-account-number"
    - path: ".pre-commit-config.yaml"
      provides: "Pre-commit hook configuration running gitleaks"
      contains: "gitleaks"
    - path: ".github/workflows/pii-check.yml"
      provides: "CI workflow for PII pattern scanning"
      contains: "PII Check"
    - path: "scripts/qa/pii-audit.sh"
      provides: "Reusable local PII audit script"
  key_links:
    - from: ".gitleaks.toml"
      to: ".pre-commit-config.yaml"
      via: "gitleaks reads .gitleaks.toml config when invoked by pre-commit hook"
      pattern: "gitleaks.*detect"
    - from: ".gitleaks.toml"
      to: ".github/workflows/pii-check.yml"
      via: "CI gitleaks-action reads .gitleaks.toml from repo root"
      pattern: "gitleaks/gitleaks-action"
---

<objective>
Install prevention hooks and CI checks to ensure PII can never re-enter the codebase after the history scrub.

Purpose: The history rewrite (Plan 02) removed existing PII. This plan ensures future commits are scanned for PII patterns before they can be committed (pre-commit hook via gitleaks) and that CI validates the entire repo on every push (GitHub Actions workflow). Together, these satisfy SEC-02 (pre-commit secrets hook) and SEC-03 (automated CI PII test).

Output: .gitleaks.toml with custom rules, .pre-commit-config.yaml with gitleaks hook, .github/workflows/pii-check.yml CI workflow, and scripts/qa/pii-audit.sh local audit script. All installed and tested.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-git-history-scrub-security-foundation/01-RESEARCH.md
@.planning/phases/01-git-history-scrub-security-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create gitleaks config with custom PII rules and pre-commit hook</name>
  <files>
    .gitleaks.toml
    .pre-commit-config.yaml
  </files>
  <action>
    **File 1: `.gitleaks.toml`**

    Create a custom gitleaks configuration with rules targeting this repo's specific PII patterns. The config extends gitleaks' 150+ built-in rules with repo-specific patterns.

    Rules to include:
    1. **fidelity-account-number** - Regex: `Z0\d{7,}` - Catches Fidelity brokerage account number format
    2. **google-sheets-id** - Regex: 44-character alphanumeric string with entropy check - Catches Google Sheets spreadsheet IDs. Use entropy >= 3.5 and keywords ["spreadsheet", "sheets", "docs.google.com"] to reduce false positives.
    3. **personal-llc-names** - Regex: `(?i)({llc_name}|KC\s*Ventures\s*Consulting\s*Group)\s*LLC` - Catches known LLC business entity names
    4. **employer-names** - Regex: `\b({employer_name})\b` - Catches known employer names. NOTE: Exclude "CBN" from this rule due to false positive risk -- it's only 3 characters. The CI grep (Task 2) will handle CBN-specific patterns with more context.
    5. **personal-names** - Regex: `(?i)\b({user_last})\b` - Catches personal family name. NOTE: Exclude first name alone as it could cause false positives in other contexts. Use the family name which is unique enough.
    6. **brightdata-api-token** - Regex: `[a-f0-9]{64}` with entropy >= 4.0 and keywords ["API_TOKEN", "api_token", "bright"] - Catches hex API tokens

    **Allowlist section:**
    ```toml
    [allowlist]
    description = "Global allowlists"
    paths = [
      '''\.gitleaks\.toml''',
      '''\.planning/phases/.*/.*-RESEARCH\.md''',
      '''scripts/qa/pii-replacements\.txt''',
      '''scripts/qa/pii-audit\.sh''',
      '''\.github/workflows/pii-check\.yml''',
    ]
    ```

    The allowlist ensures gitleaks doesn't flag the security tooling itself (which necessarily references PII patterns).

    **File 2: `.pre-commit-config.yaml`**

    ```yaml
    repos:
      - repo: https://github.com/gitleaks/gitleaks
        rev: v8.24.2
        hooks:
          - id: gitleaks
    ```

    **Install the pre-commit hook:**
    ```bash
    # Check if pre-commit is installed
    which pre-commit || brew install pre-commit

    # Install the hook
    pre-commit install

    # Verify it works by running against all files
    pre-commit run --all-files
    ```

    If gitleaks reports findings on existing files, review them:
    - If they're in allowlisted paths, the config needs adjustment
    - If they're actual PII that survived the scrub, this is a BLOCKER -- go back to Plan 02
    - If they're false positives, add path or rule-level allowlists

    **Test the hook works by attempting a PII commit:**
    ```bash
    echo "{account_id}" > /tmp/test-pii.txt
    cp /tmp/test-pii.txt test-pii-temp.txt
    git add test-pii-temp.txt
    git commit -m "test: should be blocked"  # This MUST fail
    git reset HEAD test-pii-temp.txt
    rm test-pii-temp.txt
    ```
  </action>
  <verify>
    ```bash
    # Gitleaks config exists and has custom rules
    grep "fidelity-account-number" .gitleaks.toml && echo "PASS" || echo "FAIL"
    grep "brightdata-api-token" .gitleaks.toml && echo "PASS" || echo "FAIL"

    # Pre-commit config exists
    grep "gitleaks" .pre-commit-config.yaml && echo "PASS" || echo "FAIL"

    # Hook is installed
    test -f .git/hooks/pre-commit && echo "PASS" || echo "FAIL"

    # Run gitleaks on all current files (should pass)
    pre-commit run --all-files
    ```
  </verify>
  <done>
    .gitleaks.toml has 6 custom PII detection rules with appropriate allowlists. .pre-commit-config.yaml is configured with gitleaks hook. Pre-commit hook is installed and verified: it blocks commits containing PII patterns and passes on clean files. False positive test confirmed the hook catches PII.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create CI PII check workflow and local audit script</name>
  <files>
    .github/workflows/pii-check.yml
    scripts/qa/pii-audit.sh
  </files>
  <action>
    **File 1: `.github/workflows/pii-check.yml`**

    Create a GitHub Actions workflow that runs on every push and pull request. The workflow has three jobs:

    **Job 1: Working tree PII scan (custom grep)**
    - Checkout with `fetch-depth: 0` (full history)
    - Grep all tracked files for specific known PII patterns:
      `{account_id}|Z0[0-9]{7,}|{llc_name}|{llc_short}|{spreadsheet_id}|{personal_email_1}|{personal_email_2}|9424526a[a-f0-9]{56}`
    - Exclude self (this workflow file) and the allowlisted files (.gitleaks.toml, pii-replacements.txt, pii-audit.sh)
    - FAIL if any matches found

    **Job 2: Git history PII scan (custom grep)**
    - Run `git log --all -p | grep -ciE "SPECIFIC_PATTERNS"` (same as above but without file path patterns)
    - FAIL if count > 0

    **Job 3: Gitleaks full scan**
    - Use `gitleaks/gitleaks-action@v2`
    - Reads `.gitleaks.toml` from repo root automatically
    - FAIL if any findings

    **IMPORTANT:** The workflow MUST exclude itself and the security tooling files from the grep scan. These files necessarily contain PII patterns as part of their detection logic.

    Also handle CBN specifically in the CI workflow (not in gitleaks rules, because gitleaks would have too many false positives):
    - Add a separate grep for `CBN\s+401` pattern (employer-specific context)
    - Only flag CBN when it appears in employer/benefits context

    **File 2: `scripts/qa/pii-audit.sh`**

    Create a reusable local audit script that developers can run before pushing:

    ```bash
    #!/usr/bin/env bash
    # PII Audit Script for Finance Guru
    # Run this to verify no PII exists in the working tree or git history.
    # Usage: ./scripts/qa/pii-audit.sh [--history]

    set -euo pipefail

    PASS=0
    FAIL=0

    # Specific PII patterns
    SPECIFIC_PATTERNS="{account_id}|Z0[0-9]{7,}|{llc_name}|{llc_short}|{spreadsheet_id}|{personal_email_1}|{personal_email_2}|9424526a[a-f0-9]{56}"

    # Files to exclude from scanning (they contain patterns as part of security tooling)
    EXCLUDE_PATTERNS=".gitleaks.toml|pii-replacements.txt|pii-audit.sh|pii-check.yml|01-RESEARCH.md"

    echo "=== PII Audit ==="
    echo ""

    # Check 1: Working tree
    echo "--- Check 1: Working tree scan ---"
    MATCHES=$(git ls-files | grep -vE "$EXCLUDE_PATTERNS" | xargs grep -rlE "$SPECIFIC_PATTERNS" 2>/dev/null || true)
    if [ -n "$MATCHES" ]; then
      echo "FAIL: PII found in tracked files:"
      echo "$MATCHES"
      FAIL=$((FAIL + 1))
    else
      echo "PASS: No PII in working tree"
      PASS=$((PASS + 1))
    fi

    # Check 2: .gitignore coverage
    echo ""
    echo "--- Check 2: .gitignore coverage ---"
    GITIGNORE_TARGETS=(".onboarding-progress.json" ".onboarding-state.json" ".env" ".mcp.json" "fin-guru-private/test" "test.csv" "fin-guru/data/user-profile.yaml")
    for target in "${GITIGNORE_TARGETS[@]}"; do
      if git check-ignore -q "$target" 2>/dev/null; then
        echo "  PASS: $target is gitignored"
        PASS=$((PASS + 1))
      else
        echo "  FAIL: $target is NOT gitignored"
        FAIL=$((FAIL + 1))
      fi
    done

    # Check 3: Git history (optional, slow)
    if [ "${1:-}" = "--history" ]; then
      echo ""
      echo "--- Check 3: Git history scan (this may take a moment) ---"
      HISTORY_COUNT=$(git log --all -p | grep -ciE "$SPECIFIC_PATTERNS" || true)
      if [ "$HISTORY_COUNT" -gt 0 ]; then
        echo "FAIL: Found $HISTORY_COUNT PII pattern matches in git history"
        FAIL=$((FAIL + 1))
      else
        echo "PASS: Zero PII in git history"
        PASS=$((PASS + 1))
      fi
    else
      echo ""
      echo "--- Skipping history scan (use --history flag to include) ---"
    fi

    # Summary
    echo ""
    echo "=== Summary: $PASS passed, $FAIL failed ==="
    if [ "$FAIL" -gt 0 ]; then
      exit 1
    fi
    ```

    Make the script executable: `chmod +x scripts/qa/pii-audit.sh`

    **Test the audit script:**
    ```bash
    ./scripts/qa/pii-audit.sh  # Fast mode (working tree + gitignore only)
    ./scripts/qa/pii-audit.sh --history  # Full mode (includes git history scan)
    ```

    Both runs should produce all PASS results on the filtered clone.

    **Commit everything:**
    ```bash
    git add .gitleaks.toml .pre-commit-config.yaml .github/workflows/pii-check.yml scripts/qa/pii-audit.sh
    git commit -m "security(01-03): add PII prevention hooks and CI checks

    - .gitleaks.toml: 6 custom PII detection rules with allowlists
    - .pre-commit-config.yaml: gitleaks pre-commit hook (SEC-02)
    - .github/workflows/pii-check.yml: CI PII scan on push/PR (SEC-03)
    - scripts/qa/pii-audit.sh: local PII audit script
    - Satisfies SEC-02 (pre-commit hook) and SEC-03 (CI PII test)"
    ```
  </action>
  <verify>
    ```bash
    # CI workflow exists
    test -f .github/workflows/pii-check.yml && echo "PASS" || echo "FAIL"

    # Audit script exists and is executable
    test -x scripts/qa/pii-audit.sh && echo "PASS" || echo "FAIL"

    # Run the audit script
    ./scripts/qa/pii-audit.sh

    # Verify CI workflow has all three checks
    grep "Working tree" .github/workflows/pii-check.yml || grep "working tree" .github/workflows/pii-check.yml
    grep "gitleaks" .github/workflows/pii-check.yml
    ```
  </verify>
  <done>
    CI workflow scans working tree, git history, and runs gitleaks on every push/PR. Local audit script provides same checks for pre-push verification. Both correctly exclude security tooling files from self-triggering. All files committed.
  </done>
</task>

</tasks>

<verification>
Run full verification suite:
```bash
# 1. Pre-commit hook blocks PII (functional test)
echo "{account_id}" > test-pii-temp.txt
git add test-pii-temp.txt
git commit -m "test" 2>&1 | grep -i "leak\|detect\|block" && echo "HOOK WORKS" || echo "HOOK FAILED"
git reset HEAD test-pii-temp.txt 2>/dev/null
rm -f test-pii-temp.txt

# 2. Gitleaks passes on clean repo
pre-commit run --all-files

# 3. Local audit script passes
./scripts/qa/pii-audit.sh

# 4. All security files exist
test -f .gitleaks.toml && test -f .pre-commit-config.yaml && test -f .github/workflows/pii-check.yml && test -f scripts/qa/pii-audit.sh && echo "ALL FILES PRESENT" || echo "MISSING FILES"
```
</verification>

<success_criteria>
1. Pre-commit hook blocks commits containing known PII patterns (verified with test commit)
2. Gitleaks passes on all current tracked files (zero findings)
3. CI workflow validates working tree, git history, and runs gitleaks on push/PR
4. Local audit script runs and passes with all checks green
5. Security tooling files are properly allowlisted (don't trigger false positives on themselves)
6. All prevention artifacts committed to the repo
</success_criteria>

<output>
After completion, create `.planning/phases/01-git-history-scrub-security-foundation/01-03-SUMMARY.md`
</output>
