---
phase: 08-sqqq-vs-puts-comparison
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/models/hedge_comparison_inputs.py
  - src/models/__init__.py
  - src/analysis/hedge_comparison.py
autonomous: true

must_haves:
  truths:
    - "SQQQ simulation uses day-by-day compounding with volatility drag, NOT simple -3x multiplication"
    - "Put payoff calculation accounts for IV expansion during market crashes using VIX-SPX regression"
    - "Breakeven analysis finds the exact market drop at which each hedge strategy becomes profitable"
    - "Three representative scenario paths (gradual, crash-then-flat, volatile) are generated for each market drop"
    - "SQQQ value is floored at zero (cannot go negative)"
  artifacts:
    - path: "src/models/hedge_comparison_inputs.py"
      provides: "Pydantic models for hedge comparison I/O"
      contains: "ScenarioInput, SQQQResult, PutResult, ComparisonRow, ComparisonOutput"
    - path: "src/analysis/hedge_comparison.py"
      provides: "HedgeComparisonCalculator with all simulation and comparison logic"
      contains: "class HedgeComparisonCalculator"
    - path: "src/models/__init__.py"
      provides: "Updated exports including hedge comparison models"
      contains: "hedge_comparison_inputs"
  key_links:
    - from: "src/analysis/hedge_comparison.py"
      to: "src/models/hedge_comparison_inputs.py"
      via: "import models for typed I/O"
      pattern: "from src\\.models\\.hedge_comparison_inputs import"
    - from: "src/analysis/hedge_comparison.py"
      to: "src/analysis/options.py"
      via: "reuse existing OptionsCalculator for put pricing"
      pattern: "from src\\.analysis\\.options import"
---

<objective>
Create the Pydantic models and HedgeComparisonCalculator for the SQQQ vs protective puts comparison tool.

Purpose: This is the computational core of Phase 8 -- the highest-complexity component in M2. It implements day-by-day SQQQ compounding simulation with volatility drag (HC-01), scenario path generation (HC-02), breakeven analysis (HC-03), IV expansion modeling via VIX-SPX regression (HC-04), and path-dependent disclaimers (HC-05). Without accurate simulation, the entire comparison tool produces misleading results.

Output: Two new Python files (Layer 1 models + Layer 2 calculator) following the established 3-layer architecture.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-sqqq-vs-puts-comparison/08-RESEARCH.md

Reference files for architecture patterns:
@src/models/risk_inputs.py
@src/models/__init__.py
@src/analysis/options.py
@src/CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create hedge comparison Pydantic models</name>
  <files>src/models/hedge_comparison_inputs.py, src/models/__init__.py</files>
  <action>
Create `src/models/hedge_comparison_inputs.py` following the exact pattern of `src/models/risk_inputs.py` (architecture docstring, Pydantic BaseModel, Field descriptions, validators, model_config with examples, __all__ export).

Define these models:

1. **ScenarioInput** -- Input for a single market drop scenario:
   - `market_drop_pct: float` -- Field(..., lt=0, ge=-0.99, description="Market drop as negative decimal, e.g. -0.20 for -20%")
   - `holding_days: int` -- Field(default=30, ge=1, le=252, description="Holding period in trading days")
   - `daily_volatility: float` -- Field(default=0.015, gt=0, le=0.10, description="Expected daily QQQ volatility")

2. **SQQQResult** -- SQQQ simulation result for a scenario:
   - `market_drop_pct: float`
   - `sqqq_return_pct: float` -- Actual SQQQ return after volatility drag
   - `naive_3x_return_pct: float` -- What simple -3x would give (for comparison)
   - `volatility_drag_pct: float` -- Difference (naive - actual) showing drag impact
   - `final_value: float` -- Field(..., ge=0.0, description="Final SQQQ position value (zero floor)")
   - `initial_value: float` -- Field(..., gt=0.0)
   - Add field_validator: `final_value` must be >= 0 (zero floor enforcement)

3. **PutResult** -- Protective put result for a scenario:
   - `market_drop_pct: float`
   - `put_value_after: float` -- Put value at new spot with expanded IV
   - `premium_paid: float` -- Field(..., ge=0.0)
   - `pnl: float` -- put_value_after - premium_paid
   - `pnl_pct: float` -- pnl / premium_paid
   - `iv_before: float` -- Baseline IV
   - `iv_after: float` -- IV after expansion
   - `intrinsic: float` -- max(strike - new_spot, 0)
   - `time_value: float` -- put_value_after - intrinsic

4. **ComparisonRow** -- One row of the comparison table:
   - `scenario_label: str` -- e.g., "-5% correction"
   - `market_drop_pct: float`
   - `sqqq: SQQQResult`
   - `put: PutResult`
   - `winner: Literal["sqqq", "put", "neither"]`

5. **ComparisonOutput** -- Full comparison output:
   - `scenarios: list[ComparisonRow]`
   - `sqqq_breakeven_drop: float`
   - `put_breakeven_drop: float`
   - `disclaimers: list[str]` -- Must include HC-05 disclaimer about path dependency
   - `parameters: dict` -- Config snapshot for reproducibility

Then update `src/models/__init__.py`:
- Add import block for hedge_comparison_inputs (ScenarioInput, SQQQResult, PutResult, ComparisonRow, ComparisonOutput)
- Add all 5 models to the __all__ list under a "# Hedge comparison models" comment
- Follow the exact import/export pattern of the existing options_inputs section

Do NOT add docstrings longer than the existing models -- match the style of risk_inputs.py (concise WHAT/WHY/VALIDATES comments, Field descriptions inline).
  </action>
  <verify>
Run: `uv run python -c "from src.models.hedge_comparison_inputs import ScenarioInput, SQQQResult, PutResult, ComparisonRow, ComparisonOutput; print('All models imported successfully')"`

Validate a model: `uv run python -c "from src.models.hedge_comparison_inputs import ScenarioInput; s = ScenarioInput(market_drop_pct=-0.20); print(f'Scenario: {s.market_drop_pct}')" `

Verify __init__.py: `uv run python -c "from src.models import ComparisonOutput; print('Export works')"`
  </verify>
  <done>All 5 Pydantic models (ScenarioInput, SQQQResult, PutResult, ComparisonRow, ComparisonOutput) are importable from both the direct module and src.models. ScenarioInput rejects market_drop_pct >= 0. SQQQResult enforces final_value >= 0.</done>
</task>

<task type="auto">
  <name>Task 2: Create HedgeComparisonCalculator (Layer 2)</name>
  <files>src/analysis/hedge_comparison.py</files>
  <action>
Create `src/analysis/hedge_comparison.py` following the exact pattern of `src/analysis/options.py` (architecture docstring referencing Layer 2 of 3-layer arch, class with public methods operating on Pydantic models, private helpers prefixed with underscore, type hints, docstrings with WHAT/WHY/HOW).

**Constants (module-level):**
```python
SQQQ_EXPENSE_RATIO = 0.0095  # 0.95% annual (ProShares net, with fee waiver through Sep 2026)
SQQQ_DAILY_FEE = SQQQ_EXPENSE_RATIO / 252  # ~0.00377% per trading day
SQQQ_LEVERAGE = -3  # -3x daily target

# VIX-SPX regression table: conservative estimates from historical crash data
# Sources: 2008 GFC (VIX 80-89), 2018 Volmageddon (VIX 37), 2020 COVID (VIX 82), 2025 Tariffs (VIX ~45)
# See: 08-RESEARCH.md for full calibration data
VIX_SPX_TABLE: dict[float, float] = {
    0.00:  18.0,   # Normal baseline (long-term VIX median ~17-19)
    -0.05: 28.0,   # Mild correction
    -0.10: 38.0,   # Moderate correction
    -0.20: 55.0,   # Bear market territory
    -0.40: 80.0,   # Crisis (2008/2020 levels)
}

DEFAULT_DISCLAIMERS: list[str] = [
    "EDUCATIONAL ONLY. Not investment advice. Consult a licensed financial professional.",
    "SQQQ decay is path-dependent. Results are approximate and vary with the price path taken.",
    "IV expansion estimates use a simplified VIX-SPX regression model. Actual IV behavior depends on regime, speed of decline, and market microstructure.",
    "Past VIX-SPX relationships may not hold in future crises.",
    "SQQQ simulation assumes perfect daily rebalancing. Actual SQQQ may deviate during extreme volatility.",
]
```

**Class: HedgeComparisonCalculator**

Constructor:
- Accepts optional `spot_price: float = 480.0` (default QQQ price), `put_strike: float | None = None` (default: 10% OTM, i.e., spot * 0.90), `put_premium: float = 5.0`, `sqqq_allocation: float = 10000.0`, `baseline_iv: float = 0.20`, `baseline_vix: float = 18.0`, `time_to_expiry: float = 0.20` (~73 days), `risk_free_rate: float = 0.045`, `holding_days: int = 30`, `daily_volatility: float = 0.015`.
- Store all params. If `put_strike` is None, default to `spot_price * 0.90`.
- Create `self.options_calc = OptionsCalculator()` (reuse existing from src/analysis/options.py).

**Public methods:**

1. `simulate_sqqq(self, scenario: ScenarioInput) -> SQQQResult`:
   - Generate 3 scenario paths using `_generate_scenario_paths()`.
   - Run SQQQ day-by-day simulation for each path using `_simulate_sqqq_single_path()`.
   - Use the AVERAGE of 3 path outcomes as the reported result (this accounts for path variability).
   - Also calculate naive_3x_return = -3 * market_drop_pct.
   - Calculate volatility_drag = naive_3x_return - actual_return (positive means drag cost).
   - Return SQQQResult.

2. `calculate_put_payoff(self, scenario: ScenarioInput) -> PutResult`:
   - Calculate new_spot = spot_price * (1 + market_drop_pct).
   - Estimate new_iv using `_estimate_iv_at_drop()`.
   - Price the put using `self.options_calc.price_option()` with BlackScholesInput(spot_price=new_spot, strike=put_strike, time_to_expiry=time_to_expiry, volatility=new_iv, risk_free_rate=risk_free_rate, option_type="put").
   - Calculate intrinsic = max(strike - new_spot, 0).
   - pnl = put_value - premium_paid.
   - Return PutResult.

3. `find_breakevens(self) -> tuple[float, float]`:
   - SQQQ breakeven: use `scipy.optimize.brentq` to find drop where SQQQ position value equals initial allocation. Use gradual decline path (conservative). Search range: (-0.50, -0.001).
   - Put breakeven (simple): breakeven_spot = strike - premium; drop_pct = (breakeven_spot - spot_price) / spot_price.
   - Return (sqqq_breakeven, put_breakeven).

4. `compare_all(self, scenarios: list[float]) -> ComparisonOutput`:
   - Main entry point. Accepts list of market drops (e.g., [-0.05, -0.10, -0.20, -0.40]).
   - For each drop: create ScenarioInput, call simulate_sqqq() and calculate_put_payoff().
   - Determine winner per scenario: compare SQQQ return % vs put PnL %. If both negative, winner = "neither". If both positive, pick higher return.
   - Call find_breakevens().
   - Build scenario labels: "-5% correction", "-10% correction", "-20% bear market", "-40% crash" (or programmatic: f"{int(abs(drop*100))}% decline").
   - Return ComparisonOutput with disclaimers=DEFAULT_DISCLAIMERS, parameters=dict snapshot of constructor args.

**Private methods:**

5. `_simulate_sqqq_single_path(self, daily_qqq_returns: list[float], initial_value: float) -> float`:
   - Day-by-day loop: `value *= (1.0 + SQQQ_LEVERAGE * r - SQQQ_DAILY_FEE)` then `value = max(value, 0.0)`.
   - Return final value.

6. `_generate_scenario_paths(self, target_drop_pct: float, days: int, daily_volatility: float) -> list[list[float]]`:
   - Generate 3 representative daily return paths (see research Pattern 2):
     - Path 1 (gradual): uniform daily drops such that cumulative product = (1 + target_drop_pct). Formula: `daily_return = (1 + target_drop_pct) ** (1/days) - 1`.
     - Path 2 (crash-then-flat): sharp drop over first min(5, days) days, then 0.0 for remaining.
     - Path 3 (volatile): random walk conditioned on matching the target final value. Use `numpy.random.default_rng(seed=42)` for reproducibility. Generate noise, then adjust so cumulative product matches target.
   - Return list of 3 paths.

7. `_estimate_iv_at_drop(self, market_drop_pct: float) -> float`:
   - Piecewise linear interpolation on VIX_SPX_TABLE.
   - For drops between table keys, linearly interpolate.
   - For drops beyond -0.40, extrapolate linearly from (-0.20, -0.40) segment.
   - For drops above 0.00 (shouldn't happen but guard), return baseline.
   - Scale: `new_iv = baseline_iv * (vix_at_drop / baseline_vix)`.

8. `_interpolate_vix(self, drop: float) -> float`:
   - Helper for piecewise linear interpolation on VIX_SPX_TABLE.
   - Sort keys, find bounding pair, linearly interpolate.

**Critical anti-patterns to avoid:**
- Do NOT use simple `-3 * cumulative_return` for SQQQ. MUST use the day-by-day loop.
- Do NOT import private methods from options.py (use public `price_option()` or `OptionsCalculator`).
- Do NOT hardcode VIX values without the table constant with documented sources.
- Do NOT use Monte Carlo -- use the 3 deterministic representative paths.

**Imports required:**
```python
from math import log
import numpy as np
from scipy.optimize import brentq
from src.analysis.options import OptionsCalculator
from src.models.options_inputs import BlackScholesInput
from src.models.hedge_comparison_inputs import (
    ScenarioInput, SQQQResult, PutResult, ComparisonRow, ComparisonOutput
)
```
  </action>
  <verify>
Run: `uv run python -c "from src.analysis.hedge_comparison import HedgeComparisonCalculator; calc = HedgeComparisonCalculator(); print('Calculator instantiated')"`

Quick smoke test: `uv run python -c "
from src.analysis.hedge_comparison import HedgeComparisonCalculator
calc = HedgeComparisonCalculator()
result = calc.compare_all([-0.05, -0.10, -0.20, -0.40])
print(f'Scenarios: {len(result.scenarios)}')
print(f'SQQQ breakeven: {result.sqqq_breakeven_drop:.2%}')
print(f'Put breakeven: {result.put_breakeven_drop:.2%}')
for row in result.scenarios:
    print(f'{row.scenario_label}: SQQQ {row.sqqq.sqqq_return_pct:+.1%} | Put PnL \${row.put.pnl:+,.0f} | Winner: {row.winner}')
"

Verify the SQQQ simulation is NOT simple -3x: `uv run python -c "
from src.analysis.hedge_comparison import HedgeComparisonCalculator
calc = HedgeComparisonCalculator()
from src.models.hedge_comparison_inputs import ScenarioInput
s = ScenarioInput(market_drop_pct=-0.20)
r = calc.simulate_sqqq(s)
print(f'Naive -3x: {r.naive_3x_return_pct:+.2%}')
print(f'Simulated: {r.sqqq_return_pct:+.2%}')
print(f'Drag: {r.volatility_drag_pct:.2%}')
assert abs(r.sqqq_return_pct - r.naive_3x_return_pct) > 0.001, 'ERROR: Simulation matches naive -3x -- volatility drag is missing!'
print('PASS: Volatility drag correctly diverges from naive -3x')
"
  </verify>
  <done>HedgeComparisonCalculator is importable and functional. compare_all() produces a ComparisonOutput with all 4 scenario rows. SQQQ returns differ from naive -3x due to volatility drag. Put payoff uses IV expansion from VIX-SPX regression. Breakevens are computed for both strategies. All disclaimers are present in output.</done>
</task>

</tasks>

<verification>
1. Both files follow 3-layer architecture (Layer 1 models, Layer 2 calculator)
2. Calculator reuses existing OptionsCalculator from src/analysis/options.py
3. SQQQ simulation uses day-by-day compounding formula, NOT simple -3x (HC-01)
4. Three scenario paths generated per market drop (HC-02)
5. IV expansion uses VIX-SPX regression table with documented sources (HC-04)
6. Breakeven analysis uses scipy.optimize.brentq (HC-03)
7. Disclaimers include path-dependency warning (HC-05)
8. All Pydantic models have proper Field descriptions and validators (XC-03)
9. No new dependencies required
</verification>

<success_criteria>
- `from src.models.hedge_comparison_inputs import ComparisonOutput` imports successfully
- `from src.analysis.hedge_comparison import HedgeComparisonCalculator` imports successfully
- `HedgeComparisonCalculator().compare_all([-0.05, -0.10, -0.20, -0.40])` returns a ComparisonOutput with 4 scenario rows, valid breakevens, and disclaimers
- SQQQ simulated return differs from naive -3x return by > 0.1% for -20% scenario (proving volatility drag works)
- Put payoff at -20% drop uses IV > baseline_iv (proving IV expansion works)
</success_criteria>

<output>
After completion, create `.planning/phases/08-sqqq-vs-puts-comparison/08-01-SUMMARY.md`
</output>
