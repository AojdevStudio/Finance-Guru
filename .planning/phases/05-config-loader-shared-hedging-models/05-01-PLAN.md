---
phase: 05-config-loader-shared-hedging-models
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/models/hedging_inputs.py
  - src/models/total_return_inputs.py
  - src/models/__init__.py
autonomous: true

must_haves:
  truths:
    - "HedgePosition validates ticker uppercase, strike positive, expiry as date, hedge_type as put|inverse_etf"
    - "RollSuggestion references a HedgePosition and adds suggested_strike, suggested_expiry, estimated_cost, reason"
    - "HedgeSizeRequest accepts portfolio_value, underlyings list, budget, target_contracts with proper constraints"
    - "TotalReturnInput accepts ticker, start_date, end_date, include_drip with date ordering validation"
    - "DividendRecord accepts ex_date, payment_date, amount (positive), shares_at_ex (positive)"
    - "TickerReturn outputs ticker, price_return, dividend_return, total_return, dividends list"
    - "All six models are importable from src.models"
  artifacts:
    - path: "src/models/hedging_inputs.py"
      provides: "HedgePosition, RollSuggestion, HedgeSizeRequest models"
      exports: ["HedgePosition", "RollSuggestion", "HedgeSizeRequest"]
    - path: "src/models/total_return_inputs.py"
      provides: "TotalReturnInput, DividendRecord, TickerReturn models"
      exports: ["TotalReturnInput", "DividendRecord", "TickerReturn"]
    - path: "src/models/__init__.py"
      provides: "Re-exports all six new models"
      contains: "HedgePosition"
  key_links:
    - from: "src/models/__init__.py"
      to: "src/models/hedging_inputs.py"
      via: "import statement"
      pattern: "from src\\.models\\.hedging_inputs import"
    - from: "src/models/__init__.py"
      to: "src/models/total_return_inputs.py"
      via: "import statement"
      pattern: "from src\\.models\\.total_return_inputs import"
---

<objective>
Create the six shared Pydantic models that all four hedging CLI tools (Phases 6-8) will import.

Purpose: These models are Layer 1 of the 3-layer architecture for the entire M2 Hedging milestone. Without them, no hedging calculator or CLI can be built with type safety.

Output:
- `src/models/hedging_inputs.py` with HedgePosition, RollSuggestion, HedgeSizeRequest
- `src/models/total_return_inputs.py` with TotalReturnInput, DividendRecord, TickerReturn
- Updated `src/models/__init__.py` with all six new exports
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-config-loader-shared-hedging-models/05-RESEARCH.md

# Pattern references (read these for exact conventions)
@src/models/options_inputs.py
@src/models/risk_inputs.py
@src/models/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create hedging_inputs.py with three hedging domain models</name>
  <files>src/models/hedging_inputs.py</files>
  <action>
Create `src/models/hedging_inputs.py` following the exact conventions from `options_inputs.py`:

**File structure:**
1. Module docstring with ARCHITECTURE NOTE (Layer 1 of 3), EDUCATIONAL CONTEXT explaining hedge positions, rolls, and sizing
2. Imports: `from datetime import date`, `from typing import Literal`, `from pydantic import BaseModel, Field, field_validator, model_validator`
3. Three model classes (below)
4. `__all__` list at bottom

**HedgePosition model:**
- `ticker: str` -- Field(..., description, min_length=1, max_length=10)
- `hedge_type: Literal["put", "inverse_etf"]` -- Field(..., description)
- `strike: float | None` -- Field(default=None, gt=0.0, description) -- None for inverse ETFs
- `expiry: date | None` -- Field(default=None, description) -- None for inverse ETFs
- `quantity: int` -- Field(..., gt=0, description)
- `premium_paid: float` -- Field(..., ge=0.0, description) -- per-contract for options
- `entry_date: date` -- Field(..., description)
- `contract_symbol: str | None` -- Field(default=None, description, max_length=30) -- None for inverse ETFs
- field_validator for `ticker`: must be uppercase (copy pattern from research)
- model_validator(mode="after"): if hedge_type=="put", strike and expiry must not be None
- model_config with json_schema_extra example showing a put position
- Docstring with WHAT/WHY/VALIDATES pattern

**RollSuggestion model:**
- `current_position: HedgePosition` -- Field(..., description)
- `suggested_strike: float` -- Field(..., gt=0.0, description)
- `suggested_expiry: date` -- Field(..., description)
- `estimated_cost: float` -- Field(..., ge=0.0, description) -- per-contract
- `reason: str` -- Field(..., description, min_length=1)
- field_validator for `suggested_expiry`: must be after today
- Docstring with WHAT/WHY/VALIDATES

**HedgeSizeRequest model:**
- `portfolio_value: float` -- Field(..., gt=0.0, description)
- `underlyings: list[str]` -- Field(..., description, min_length=1)
- `budget: float` -- Field(..., gt=0.0, description) -- total budget for this sizing
- `target_contracts: int | None` -- Field(default=None, gt=0, description) -- None means auto-calculate
- field_validator for `underlyings`: each must be uppercase, 1-10 chars
- Docstring with WHAT/WHY/VALIDATES

**IMPORTANT conventions to match (from options_inputs.py):**
- Use `Field(...)` for required fields (not `Field(default=...)`)
- Use `@field_validator("field_name")` with `@classmethod` decorator
- Use `model_config = { "json_schema_extra": { "examples": [...] } }` not `class Config:`
- NEVER import from total_return_inputs.py (no circular imports)
  </action>
  <verify>
Run: `uv run python -c "from src.models.hedging_inputs import HedgePosition, RollSuggestion, HedgeSizeRequest; print('OK')"` -- must print OK.

Verify validation:
```bash
uv run python -c "
from src.models.hedging_inputs import HedgePosition
from datetime import date
# Valid put
p = HedgePosition(ticker='QQQ', hedge_type='put', strike=420.0, expiry=date(2026,4,17), quantity=2, premium_paid=8.50, entry_date=date(2026,2,1), contract_symbol='QQQ260417P00420000')
print(f'Put: {p.ticker} {p.hedge_type} {p.strike}')
# Valid inverse ETF
e = HedgePosition(ticker='SQQQ', hedge_type='inverse_etf', quantity=100, premium_paid=25.50, entry_date=date(2026,2,1))
print(f'ETF: {e.ticker} {e.hedge_type}')
print('Validation OK')
"
```
  </verify>
  <done>hedging_inputs.py exists with three models (HedgePosition, RollSuggestion, HedgeSizeRequest), all importable, with field_validators for ticker uppercase + model_validator for put-requires-strike-and-expiry</done>
</task>

<task type="auto">
  <name>Task 2: Create total_return_inputs.py with three return calculation models</name>
  <files>src/models/total_return_inputs.py</files>
  <action>
Create `src/models/total_return_inputs.py` following the exact conventions from `options_inputs.py`:

**File structure:**
1. Module docstring with ARCHITECTURE NOTE (Layer 1 of 3), EDUCATIONAL CONTEXT explaining total return = price return + dividend return, DRIP concept
2. Imports: `from datetime import date`, `from pydantic import BaseModel, Field, field_validator, model_validator`
3. Three model classes (below)
4. `__all__` list at bottom

**DividendRecord model** (define FIRST, since TickerReturn references it):
- `ex_date: date` -- Field(..., description)
- `payment_date: date | None` -- Field(default=None, description) -- may not always be available
- `amount: float` -- Field(..., gt=0.0, description) -- per-share dividend amount
- `shares_at_ex: float` -- Field(..., gt=0.0, description) -- shares held at ex-date (fractional for DRIP)
- Docstring with WHAT/WHY/VALIDATES

**TotalReturnInput model:**
- `ticker: str` -- Field(..., description, min_length=1, max_length=10)
- `start_date: date` -- Field(..., description)
- `end_date: date` -- Field(..., description)
- `include_drip: bool` -- Field(default=True, description) -- whether to model dividend reinvestment
- `initial_shares: float` -- Field(default=1.0, gt=0.0, description) -- starting share count
- field_validator for `ticker`: must be uppercase
- model_validator(mode="after"): end_date must be after start_date
- model_config with json_schema_extra example
- Docstring with WHAT/WHY/VALIDATES

**TickerReturn model** (output model):
- `ticker: str` -- Field(..., description)
- `start_date: date` -- Field(..., description)
- `end_date: date` -- Field(..., description)
- `price_return: float` -- Field(..., description) -- as decimal (0.15 = 15%)
- `dividend_return: float` -- Field(..., description) -- as decimal
- `total_return: float` -- Field(..., description) -- price_return + dividend_return
- `dividends: list[DividendRecord]` -- Field(default_factory=list, description)
- `final_shares: float` -- Field(default=1.0, gt=0.0, description) -- after DRIP
- `data_quality_warnings: list[str]` -- Field(default_factory=list, description) -- any data gaps
- model_validator(mode="after"): total_return should approximately equal price_return + dividend_return (warn if off by >0.01 but don't reject)
- Docstring with WHAT/WHY/VALIDATES

**IMPORTANT conventions:**
- NEVER import from hedging_inputs.py (no circular imports)
- Use same Field/validator patterns as hedging_inputs.py
- DividendRecord defined before TickerReturn (forward reference order)
  </action>
  <verify>
Run: `uv run python -c "from src.models.total_return_inputs import TotalReturnInput, DividendRecord, TickerReturn; print('OK')"` -- must print OK.

Verify validation:
```bash
uv run python -c "
from src.models.total_return_inputs import TotalReturnInput, DividendRecord, TickerReturn
from datetime import date
# Valid input
inp = TotalReturnInput(ticker='SCHD', start_date=date(2025,1,1), end_date=date(2026,1,1))
print(f'Input: {inp.ticker} drip={inp.include_drip}')
# Valid dividend
div = DividendRecord(ex_date=date(2025,3,15), amount=0.65, shares_at_ex=100.0)
print(f'Div: {div.amount}')
# Valid output
ret = TickerReturn(ticker='SCHD', start_date=date(2025,1,1), end_date=date(2026,1,1), price_return=0.10, dividend_return=0.035, total_return=0.135, dividends=[div], final_shares=102.5)
print(f'Return: {ret.total_return}')
print('Validation OK')
"
```
  </verify>
  <done>total_return_inputs.py exists with three models (TotalReturnInput, DividendRecord, TickerReturn), all importable, with date ordering validation and DRIP-aware fields</done>
</task>

<task type="auto">
  <name>Task 3: Update src/models/__init__.py to export all six new models</name>
  <files>src/models/__init__.py</files>
  <action>
Add imports and exports for the six new models to `src/models/__init__.py`.

**Add these import blocks** after the existing `options_inputs` imports (at the end of the import section):

```python
from src.models.hedging_inputs import (
    HedgePosition,
    RollSuggestion,
    HedgeSizeRequest,
)

from src.models.total_return_inputs import (
    TotalReturnInput,
    DividendRecord,
    TickerReturn,
)
```

**Add to `__all__` list** (at the end, before the closing bracket):

```python
    # Hedging models
    "HedgePosition",
    "RollSuggestion",
    "HedgeSizeRequest",
    # Total return models
    "TotalReturnInput",
    "DividendRecord",
    "TickerReturn",
```

**Update module docstring** to add:
```
    - hedging_inputs: Hedging position models (HedgePosition, RollSuggestion, HedgeSizeRequest)
    - total_return_inputs: Total return models (TotalReturnInput, DividendRecord, TickerReturn)
```

Follow the exact grouping and comment style of the existing exports.
  </action>
  <verify>
Run: `uv run python -c "from src.models import HedgePosition, RollSuggestion, HedgeSizeRequest, TotalReturnInput, DividendRecord, TickerReturn; print('All 6 models imported from src.models')"` -- must succeed.

Run: `uv run python -c "import src.models; print(len(src.models.__all__))"` -- should show previous count + 6 new exports.
  </verify>
  <done>src/models/__init__.py exports all six new models, importable via `from src.models import HedgePosition` etc.</done>
</task>

</tasks>

<verification>
Run all three verification commands from the tasks above.

Then confirm no circular imports:
```bash
uv run python -c "
import src.models.hedging_inputs
import src.models.total_return_inputs
print('No circular imports')
"
```

Confirm model count:
```bash
uv run python -c "
from src.models import __all__
print(f'Total exported models: {len(__all__)}')
assert len(__all__) >= 39, f'Expected at least 39 exports (33 existing + 6 new), got {len(__all__)}'
print('Count OK')
"
```
</verification>

<success_criteria>
1. `src/models/hedging_inputs.py` exists with HedgePosition, RollSuggestion, HedgeSizeRequest -- all with proper Pydantic v2 conventions
2. `src/models/total_return_inputs.py` exists with TotalReturnInput, DividendRecord, TickerReturn -- all self-contained
3. All six models importable from `src.models` via __init__.py
4. No circular imports between hedging_inputs and total_return_inputs
5. All validators work: uppercase ticker, positive strike, date ordering, put-requires-strike
</success_criteria>

<output>
After completion, create `.planning/phases/05-config-loader-shared-hedging-models/05-01-SUMMARY.md`
</output>
