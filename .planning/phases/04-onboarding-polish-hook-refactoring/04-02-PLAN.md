---
phase: 04-onboarding-polish-hook-refactoring
plan: 02
type: execute
wave: 2
depends_on: ["03-02"]
files_modified:
  - src/cli/onboarding_wizard.py
  - tests/python/test_onboarding_wizard.py
  - .gitignore
autonomous: true

must_haves:
  truths:
    - "Pressing Ctrl+C mid-onboarding saves progress to .onboarding-progress.json at the project root"
    - "Restarting the onboarding wizard detects the progress file and offers to resume from the last incomplete section"
    - "Completing onboarding successfully deletes .onboarding-progress.json (no stale file left behind)"
    - "A corrupt or invalid progress file is silently ignored and the wizard starts fresh"
    - "All 365+ existing pytest tests pass after save/resume changes (zero regressions)"
    - ".onboarding-progress.json is gitignored (contains partially-entered financial data)"
  artifacts:
    - path: "src/cli/onboarding_wizard.py"
      provides: "SIGINT handler, atomic progress file save/load, section-level resume logic, progress file cleanup on completion"
      contains: "signal.signal"
    - path: "tests/python/test_onboarding_wizard.py"
      provides: "Tests for save-on-interrupt, resume-from-progress, corrupt-file-handling, cleanup-on-completion"
      contains: "onboarding-progress"
    - path: ".gitignore"
      provides: "Entry for .onboarding-progress.json"
      contains: ".onboarding-progress.json"
  key_links:
    - from: "src/cli/onboarding_wizard.py"
      to: ".onboarding-progress.json"
      via: "atomic write (tempfile + rename) on interrupt/section-complete; load + validate on startup"
      pattern: "onboarding-progress\\.json"
    - from: "src/cli/onboarding_wizard.py"
      to: "src/models/onboarding_inputs.py"
      via: "OnboardingState.model_dump(mode='json') for serialization, model_validate() for loading"
      pattern: "model_dump|model_validate"
    - from: "src/cli/onboarding_wizard.py"
      to: "signal"
      via: "signal.signal(signal.SIGINT, handler) for Ctrl+C interception"
      pattern: "signal\\.signal.*SIGINT"
---

<objective>
Add interruption-safe progress persistence to the onboarding wizard so that Ctrl+C saves the current state and restarting the wizard resumes from where the user left off.

Purpose: Without save/resume, users who are interrupted mid-onboarding (Ctrl+C, terminal close, laptop sleep) must restart the entire 8-section flow from scratch. This plan adds a SIGINT handler + atexit safety net that persists OnboardingState to .onboarding-progress.json using atomic writes, and resume logic that detects the file on startup. This completes ONBD-03 and ONBD-16 (regression testing).

Output: Modified onboarding_wizard.py with save/resume behavior, updated test file with save/resume test cases, and .gitignore entry for the progress file.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-onboarding-polish-hook-refactoring/04-RESEARCH.md
@.planning/phases/03-onboarding-wizard/03-01-PLAN.md
@.planning/phases/03-onboarding-wizard/03-02-PLAN.md

# Phase 3 output -- read the SUMMARY for exact implementation details
@.planning/phases/03-onboarding-wizard/03-02-SUMMARY.md

# Key source files from Phase 3
@src/cli/onboarding_wizard.py
@src/models/onboarding_inputs.py
@src/utils/onboarding_sections.py
@tests/python/test_onboarding_wizard.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add save/resume logic to onboarding wizard</name>
  <files>
    src/cli/onboarding_wizard.py
    src/models/onboarding_inputs.py
    .gitignore
  </files>
  <action>
    **Step 1: Add .onboarding-progress.json to .gitignore**

    Add this entry to `.gitignore` (in the section with other runtime/temporary files, near the .env and fin-guru-private entries):
    ```
    .onboarding-progress.json
    ```

    **Step 2: Add progress persistence methods to OnboardingState (if not already present)**

    In `src/models/onboarding_inputs.py`, verify that `OnboardingState` has these capabilities (Phase 3 may have already defined the model):
    - `model_dump(mode="json")` works for JSON serialization (Pydantic v2 provides this automatically)
    - `model_validate()` works for deserialization from dict (Pydantic v2 provides this automatically)
    - The model includes `current_section` (SectionName), `completed_sections` (list of SectionName), and section data fields

    If OnboardingState does not have a `started_at: datetime` field, add one with `default_factory=datetime.utcnow`. This timestamps when the onboarding session began and is included in the progress file for debugging.

    **Step 3: Add save/load/delete functions to onboarding_wizard.py**

    Add these functions to `src/cli/onboarding_wizard.py`:

    ```python
    import signal
    import atexit
    import json
    import tempfile
    from pathlib import Path

    PROGRESS_FILE = Path(".onboarding-progress.json")

    def save_progress(state) -> None:
        """Atomically save wizard progress to .onboarding-progress.json.

        Uses tempfile + rename pattern for crash safety:
        write to temp file in same directory, then atomic rename.
        """
        data = state.model_dump(mode="json")
        tmp_fd, tmp_path = tempfile.mkstemp(
            dir=PROGRESS_FILE.parent or Path("."),
            suffix=".tmp",
            prefix=".onboarding-progress-"
        )
        try:
            with open(tmp_fd, "w") as f:
                json.dump(data, f, indent=2)
            Path(tmp_path).rename(PROGRESS_FILE)
        except Exception:
            Path(tmp_path).unlink(missing_ok=True)
            raise

    def load_progress():
        """Load saved progress, return None if not found or corrupt.

        A corrupt file (invalid JSON or schema mismatch) is silently
        ignored -- the wizard starts fresh. This handles edge cases
        where a prior save was interrupted mid-write (though atomic
        rename makes this unlikely).
        """
        if not PROGRESS_FILE.exists():
            return None
        try:
            data = json.loads(PROGRESS_FILE.read_text())
            return OnboardingState.model_validate(data)
        except (json.JSONDecodeError, Exception):
            return None

    def delete_progress() -> None:
        """Delete progress file after successful completion."""
        PROGRESS_FILE.unlink(missing_ok=True)
    ```

    **Step 4: Add WizardInterruptHandler class**

    Add an interrupt handler class that registers both SIGINT and atexit:

    ```python
    class WizardInterruptHandler:
        """Two-layer safety net for saving wizard progress on interrupt.

        Layer 1: SIGINT handler -- catches Ctrl+C, saves progress, prints message.
        Layer 2: atexit handler -- backup save on any clean exit.

        Note: questionary (via prompt_toolkit) installs its own SIGINT handler
        during prompts, so .ask() returns None on Ctrl+C. The SIGINT handler
        here is a BACKUP for interrupts between prompts (during processing).
        The primary interrupt detection is checking for None return from .ask().
        """

        def __init__(self):
            self._state = None
            self._active = False

        def setup(self):
            """Register signal and atexit handlers."""
            signal.signal(signal.SIGINT, self._handle_sigint)
            atexit.register(self._save_on_exit)
            self._active = True

        def update_state(self, state):
            """Update the current state reference after each section."""
            self._state = state

        def deactivate(self):
            """Deactivate after successful completion (prevent stale saves)."""
            self._active = False
            self._state = None

        def _handle_sigint(self, signum, frame):
            """SIGINT handler: save progress and exit."""
            self._save_on_exit()
            print("\n\nProgress saved. Run the wizard again to resume.")
            raise SystemExit(0)

        def _save_on_exit(self):
            """Save progress if there is anything to save."""
            if not self._active or self._state is None:
                return
            if hasattr(self._state, 'completed_sections') and len(self._state.completed_sections) > 0:
                try:
                    save_progress(self._state)
                except Exception:
                    pass  # Best effort on exit
    ```

    **Step 5: Modify the wizard main function to support resume**

    Modify the main wizard function (the entry point that orchestrates the 8 sections) to:

    a) At startup, BEFORE creating a new OnboardingState:
       - Call `load_progress()` to check for a saved session
       - If a saved session exists with completed_sections > 0:
         - Print what was completed: "Found saved progress: {N} of 8 sections complete."
         - Ask via questionary.confirm: "Resume from where you left off?" (default=True)
         - If yes: use the loaded state, skip to `current_section`
         - If no: create a fresh OnboardingState

    b) Set up the interrupt handler:
       - Create `handler = WizardInterruptHandler()` and call `handler.setup()`

    c) In the section loop, after each section completes:
       - Call `handler.update_state(state)` with the updated state
       - Call `save_progress(state)` to save after each completed section

    d) Wrap the section loop in a try/except for KeyboardInterrupt:
       - On KeyboardInterrupt: call `save_progress(state)`, print "Progress saved. Run the wizard again to resume.", return/exit

    e) On successful completion (all 8 sections done, config files generated):
       - Call `handler.deactivate()` FIRST (prevents atexit from re-saving)
       - Call `delete_progress()` to remove the progress file

    **IMPORTANT behavioral details:**
    - The resume prompt should use questionary.confirm, NOT input(). This keeps the UX consistent.
    - If the user declines to resume, delete the old progress file before starting fresh.
    - The section loop skip logic: get the index of `current_section` in the SECTION_ORDER list, then iterate from that index forward.
    - Do NOT save progress if zero sections are completed (nothing useful to resume from).
    - The progress file goes at the project root (same directory as pyproject.toml), NOT in fin-guru-private/.
  </action>
  <verify>
    1. `grep "signal.signal" src/cli/onboarding_wizard.py` -- confirms SIGINT handler is registered
    2. `grep "onboarding-progress.json" src/cli/onboarding_wizard.py` -- confirms progress file path is referenced
    3. `grep "onboarding-progress.json" .gitignore` -- confirms gitignore entry exists
    4. `grep "delete_progress\|unlink" src/cli/onboarding_wizard.py` -- confirms cleanup on completion
    5. `grep "load_progress\|model_validate" src/cli/onboarding_wizard.py` -- confirms resume logic exists
  </verify>
  <done>
    The onboarding wizard has SIGINT + atexit interrupt handling, atomic progress file save/load, section-level resume on restart, and progress file cleanup on successful completion. .onboarding-progress.json is gitignored.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write save/resume tests and run full regression suite</name>
  <files>
    tests/python/test_onboarding_wizard.py
  </files>
  <action>
    **Step 1: Add save/resume test cases to the existing wizard test file**

    In `tests/python/test_onboarding_wizard.py` (created by Phase 3 Plan 02), add a new test class or section for save/resume behavior. Use pytest fixtures and mocker (pytest-mock) to isolate file I/O.

    **Test cases to add:**

    a) **test_save_progress_creates_valid_json**
       - Create an OnboardingState with 2 completed sections and test data
       - Call `save_progress(state)` with a tmp_path fixture for the progress file
       - Read the file, parse as JSON, validate it round-trips back to an equivalent OnboardingState
       - Use `monkeypatch` to override `PROGRESS_FILE` to point at `tmp_path / ".onboarding-progress.json"`

    b) **test_load_progress_returns_saved_state**
       - Write a valid progress JSON to the expected path
       - Call `load_progress()` and verify the returned state has the correct current_section and completed_sections

    c) **test_load_progress_returns_none_for_missing_file**
       - Ensure no progress file exists
       - Call `load_progress()` and verify it returns None

    d) **test_load_progress_returns_none_for_corrupt_json**
       - Write invalid JSON (e.g., "not valid json {{{") to the progress file
       - Call `load_progress()` and verify it returns None (no crash)

    e) **test_load_progress_returns_none_for_invalid_schema**
       - Write valid JSON but with wrong schema (e.g., `{"wrong_field": true}`)
       - Call `load_progress()` and verify it returns None (Pydantic validation fails gracefully)

    f) **test_delete_progress_removes_file**
       - Create a progress file
       - Call `delete_progress()`
       - Verify the file no longer exists

    g) **test_delete_progress_noop_if_no_file**
       - Ensure no progress file exists
       - Call `delete_progress()` -- should not raise

    h) **test_wizard_saves_progress_after_each_section** (integration)
       - Mock questionary to provide valid answers for the first 2 sections, then return None (simulating Ctrl+C)
       - Run the wizard
       - Verify .onboarding-progress.json was created with 2 completed sections

    i) **test_wizard_resumes_from_saved_progress** (integration)
       - Pre-create a progress file with 3 sections completed
       - Mock questionary.confirm to return True (resume)
       - Mock remaining section prompts
       - Run the wizard
       - Verify it skipped the first 3 sections and ran sections 4-8

    j) **test_wizard_deletes_progress_on_completion** (integration)
       - Pre-create a progress file
       - Mock all questionary prompts to provide valid answers for all remaining sections
       - Run the wizard to completion
       - Verify .onboarding-progress.json does NOT exist after completion

    **Important test implementation details:**
    - Use `monkeypatch.setattr` to override `PROGRESS_FILE` path to a temp directory (prevents writing to actual project root during tests)
    - Use `mocker.patch("questionary.confirm")` and `mocker.patch("questionary.select")` etc. to simulate user input (same pattern as existing Phase 3 tests)
    - For the integration tests, patch at the questionary function level (not stdin) -- this is the established pattern from Phase 3
    - Import save_progress, load_progress, delete_progress from `src.cli.onboarding_wizard`

    **Step 2: Run the new tests**

    ```bash
    uv run pytest tests/python/test_onboarding_wizard.py -v
    ```

    All new save/resume tests must pass.

    **Step 3: Run the FULL pytest regression suite**

    ```bash
    uv run pytest tests/python/ -x -q
    ```

    All 365+ existing tests PLUS the new save/resume tests must pass. Zero regressions. This is the ONBD-16 requirement.

    If any existing tests fail, diagnose and fix. The save/resume changes should NOT affect existing tests because:
    - The SIGINT handler is only registered when the wizard's main function is called
    - The progress file functions are new additions, not modifications to existing code
    - No existing imports or module-level code should change
  </action>
  <verify>
    1. `uv run pytest tests/python/test_onboarding_wizard.py -v -k "save_progress or load_progress or delete_progress or resume"` -- all save/resume tests pass
    2. `uv run pytest tests/python/ -x -q` -- full suite shows 365+ tests passed, 0 failed
    3. `grep -c "def test_" tests/python/test_onboarding_wizard.py` -- shows increased test count (original count + 10 new)
  </verify>
  <done>
    Save/resume test suite covers: save creates valid JSON, load returns saved state, load handles missing/corrupt/invalid files gracefully, delete removes file, delete is safe when no file exists, wizard saves after each section, wizard resumes from saved progress, wizard deletes progress on completion. Full pytest regression suite (365+ tests) passes with zero regressions.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Interrupt behavior verified:**
   ```bash
   # Simulate: start wizard, complete 2 sections, Ctrl+C
   # Then: restart wizard, confirm resume prompt appears
   # (This is a manual verification -- the automated tests cover the logic)
   ```

2. **Progress file lifecycle verified:**
   ```bash
   # After interrupt: .onboarding-progress.json exists with completed sections
   # After successful completion: .onboarding-progress.json does NOT exist
   ```

3. **Regression suite clean:**
   ```bash
   uv run pytest tests/python/ -x -q
   # 365+ tests pass, 0 failures
   ```

4. **Gitignore confirmed:**
   ```bash
   git check-ignore .onboarding-progress.json
   # Returns the file path (confirming it's ignored)
   ```
</verification>

<success_criteria>
- Ctrl+C mid-onboarding saves progress to .onboarding-progress.json (ONBD-03)
- Restarting onboarding resumes from last incomplete section (ONBD-03)
- Successful completion deletes the progress file (no stale file)
- Corrupt progress files are handled gracefully (start fresh)
- All 365+ existing pytest tests pass with zero regressions (ONBD-16)
- .onboarding-progress.json is gitignored
</success_criteria>

<output>
After completion, create `.planning/phases/04-onboarding-polish-hook-refactoring/04-02-SUMMARY.md`
</output>
