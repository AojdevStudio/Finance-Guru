---
phase: 05-agent-readiness-hardening
plan: 05
type: execute
wave: 3
depends_on: ["05-03"]
files_modified:
  - tests/python/test_volatility_calc.py
  - tests/python/test_momentum_calc.py
  - tests/python/test_moving_averages_calc.py
  - tests/python/test_market_data.py
autonomous: true

must_haves:
  truths:
    - "volatility.py has test coverage above 80%"
    - "momentum.py has test coverage above 80%"
    - "moving_averages.py has test coverage above 80%"
    - "market_data.py has test coverage above 80%"
  artifacts:
    - path: "tests/python/test_volatility_calc.py"
      provides: "Tests for VolatilityCalculator"
      contains: "class TestVolatilityCalculator"
    - path: "tests/python/test_momentum_calc.py"
      provides: "Tests for momentum calculator"
      contains: "class TestMomentum"
    - path: "tests/python/test_moving_averages_calc.py"
      provides: "Tests for MovingAverageCalculator"
      contains: "class TestMovingAverage"
    - path: "tests/python/test_market_data.py"
      provides: "Tests for market data fetching"
      contains: "class TestMarketData"
  key_links:
    - from: "tests/python/test_volatility_calc.py"
      to: "src/utils/volatility.py"
      via: "import and test VolatilityCalculator"
      pattern: "from src.utils.volatility import"
    - from: "tests/python/test_momentum_calc.py"
      to: "src/utils/momentum.py"
      via: "import and test MomentumCalculator"
      pattern: "from src.utils.momentum import"
---

<objective>
Write comprehensive test suites for the four utility calculator modules (volatility, momentum, moving_averages, market_data) to bring them from 0% to 80%+ coverage.

Purpose: These are Layer 2 calculators forming the foundation of the analysis toolkit. Testing them contributes ~393 statements toward the 80% coverage target.
Output: Four new test files in tests/python/.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/TESTING.md
@src/utils/volatility.py
@src/utils/momentum.py
@src/utils/moving_averages.py
@src/utils/market_data.py
@src/models/volatility_inputs.py
@src/models/momentum_inputs.py
@src/models/moving_avg_inputs.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write tests for volatility.py and momentum.py calculators</name>
  <files>
    tests/python/test_volatility_calc.py
    tests/python/test_momentum_calc.py
  </files>
  <action>
  Read src/utils/volatility.py (74 stmts) and src/utils/momentum.py (103 stmts) to understand their public APIs, then write test suites.

  **For test_volatility_calc.py:**
  1. Read volatility.py to identify the calculator class and its methods
  2. Create mock OHLCV price data using numpy/pandas (do NOT call real APIs)
  3. Test each public method of VolatilityCalculator:
     - Bollinger Bands calculation (returns upper, middle, lower bands)
     - ATR (Average True Range) calculation
     - Historical volatility calculation
     - Keltner Channels
     - Standard deviation calculation
     - Volatility regime detection
  4. Test edge cases: minimum data points, flat prices (zero volatility), extreme moves
  5. Verify Pydantic output models are correctly populated

  **For test_momentum_calc.py:**
  1. Read momentum.py to identify the calculator class and its methods
  2. Create mock price data with known momentum characteristics
  3. Test each public method:
     - RSI calculation (verify 0-100 range, known values)
     - MACD calculation (signal line, histogram)
     - Stochastic oscillator
     - Williams %R
     - Rate of Change (ROC)
     - Confluence scoring
  4. Test edge cases: all up days, all down days, alternating prices
  5. Verify outputs are Pydantic models with correct field types

  **Testing pattern** (follow existing project conventions):
  ```python
  import pytest
  import numpy as np
  import pandas as pd
  from unittest.mock import MagicMock, patch

  class TestVolatilityCalculator:
      """Tests for VolatilityCalculator."""

      def _make_price_data(self, n=100):
          """Create mock OHLCV DataFrame."""
          np.random.seed(42)
          close = 100 + np.cumsum(np.random.randn(n) * 2)
          return pd.DataFrame({
              'Open': close + np.random.randn(n),
              'High': close + abs(np.random.randn(n)),
              'Low': close - abs(np.random.randn(n)),
              'Close': close,
              'Volume': np.random.randint(1000000, 5000000, n)
          })

      def test_bollinger_bands_calculation(self):
          # Arrange, Act, Assert pattern
          ...
  ```

  Each test file should have 15-25 tests targeting all branches of the calculator code.
  </action>
  <verify>
  - `uv run pytest tests/python/test_volatility_calc.py tests/python/test_momentum_calc.py -v` passes all tests
  - `uv run pytest tests/python/test_volatility_calc.py --cov=src/utils/volatility --cov-report=term-missing` shows >= 80% coverage
  - `uv run pytest tests/python/test_momentum_calc.py --cov=src/utils/momentum --cov-report=term-missing` shows >= 80% coverage
  </verify>
  <done>test_volatility_calc.py covers volatility.py at 80%+. test_momentum_calc.py covers momentum.py at 80%+. All tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Write tests for moving_averages.py and market_data.py</name>
  <files>
    tests/python/test_moving_averages_calc.py
    tests/python/test_market_data.py
  </files>
  <action>
  Read src/utils/moving_averages.py (118 stmts) and src/utils/market_data.py (98 stmts), then write test suites.

  **For test_moving_averages_calc.py:**
  1. Read moving_averages.py to identify MovingAverageCalculator class and methods
  2. Create mock price series with known moving average values
  3. Test each MA type: SMA, EMA, WMA, HMA
  4. Test crossover detection (golden cross, death cross)
  5. Test with different periods (short, long)
  6. Test edge cases: insufficient data, single-point series
  7. Verify output Pydantic models

  **For test_market_data.py:**
  1. Read market_data.py to understand the data fetching interface
  2. Mock yfinance API calls -- do NOT make real API calls
  3. Test successful data fetch (mock returns valid DataFrame)
  4. Test error handling (ticker not found, network error, empty data)
  5. Test data validation (returned prices are positive, dates are sorted)
  6. Test caching behavior if present
  7. Mark any tests that NEED real API calls with @pytest.mark.integration

  **Mock pattern for yfinance:**
  ```python
  @patch("src.utils.market_data.yf.Ticker")
  def test_fetch_prices_success(self, mock_ticker):
      mock_hist = pd.DataFrame({
          'Close': [100.0, 101.0, 102.0],
          'Open': [99.0, 100.0, 101.0],
          'High': [101.0, 102.0, 103.0],
          'Low': [98.0, 99.0, 100.0],
          'Volume': [1000000, 1100000, 1200000]
      }, index=pd.date_range('2025-01-01', periods=3))
      mock_ticker.return_value.history.return_value = mock_hist

      result = get_prices("TSLA", days=3)
      assert len(result) == 3
  ```
  </action>
  <verify>
  - `uv run pytest tests/python/test_moving_averages_calc.py tests/python/test_market_data.py -v` passes all tests
  - `uv run pytest tests/python/test_moving_averages_calc.py --cov=src/utils/moving_averages --cov-report=term-missing` shows >= 80% coverage
  - `uv run pytest tests/python/test_market_data.py --cov=src/utils/market_data --cov-report=term-missing` shows >= 80% coverage
  </verify>
  <done>test_moving_averages_calc.py covers moving_averages.py at 80%+. test_market_data.py covers market_data.py at 80%+. All tests pass.</done>
</task>

</tasks>

<verification>
1. All four new test files pass: `uv run pytest tests/python/test_volatility_calc.py tests/python/test_momentum_calc.py tests/python/test_moving_averages_calc.py tests/python/test_market_data.py -v`
2. Each source module has >= 80% coverage individually
3. Full test suite still passes: `uv run pytest -x -q`
</verification>

<success_criteria>
Four new test files written and passing. volatility.py, momentum.py, moving_averages.py, and market_data.py each have 80%+ test coverage.
</success_criteria>

<output>
After completion, create `.planning/phases/05-agent-readiness-hardening/05-05-SUMMARY.md`
</output>
