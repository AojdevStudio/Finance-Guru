---
phase: 07-total-return-calculator
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - fin-guru-private/dividend-schedules.yaml
  - src/analysis/total_return.py
  - tests/python/test_total_return.py
autonomous: true

must_haves:
  truths:
    - "TotalReturnCalculator computes price return, dividend return, and total return as three distinct numbers"
    - "DRIP calculation reinvests dividends at ex-date close price and tracks growing share count"
    - "Both with-DRIP and without-DRIP returns are computed in a single calculate_all() call"
    - "Dividend data quality validation detects gaps vs expected schedule and refuses to calculate (returns error)"
    - "--force semantics: when force=True, validation warns but does not refuse"
    - "Annualized return uses calendar days (365), not trading days (252)"
    - "Split artifact detection flags dividends >3x median as suspicious"
  artifacts:
    - path: "fin-guru-private/dividend-schedules.yaml"
      provides: "Per-ticker dividend frequency metadata (monthly, weekly, quarterly)"
      contains: "CLM"
    - path: "src/analysis/total_return.py"
      provides: "TotalReturnCalculator class with calculate_all(), validate_dividend_data(), calculate_drip_return()"
      min_lines: 150
    - path: "tests/python/test_total_return.py"
      provides: "Known-answer tests for all calculator methods"
      min_lines: 200
  key_links:
    - from: "src/analysis/total_return.py"
      to: "src/models/total_return_inputs.py"
      via: "import TotalReturnInput, DividendRecord, TickerReturn"
      pattern: "from src\\.models\\.total_return_inputs import"
    - from: "src/analysis/total_return.py"
      to: "fin-guru-private/dividend-schedules.yaml"
      via: "YAML load for expected dividend frequencies"
      pattern: "dividend.schedules\\.yaml|load_dividend_schedules"
    - from: "tests/python/test_total_return.py"
      to: "src/analysis/total_return.py"
      via: "import TotalReturnCalculator"
      pattern: "from src\\.analysis\\.total_return import"
---

<objective>
Build the TotalReturnCalculator class (Layer 2) using TDD, along with the dividend schedule configuration file. This calculator computes price return, dividend return, total return, DRIP return (with and without reinvestment), and validates dividend data quality against known schedules.

Purpose: This is the core business logic for Phase 7. The calculator must produce three distinct return numbers (TR-01), model DRIP reinvestment at ex-date close prices (TR-02), and detect data quality issues (TR-03). It follows the established 3-layer architecture where Layer 2 contains all business logic.

Output: Working `TotalReturnCalculator` class with comprehensive known-answer test suite, plus dividend schedule config YAML.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-total-return-calculator/07-RESEARCH.md
@.planning/phases/07-total-return-calculator/07-CONTEXT.md
@.planning/phases/06-config-loader-shared-hedging-models/06-01-SUMMARY.md

@src/CLAUDE.md
@src/models/total_return_inputs.py
@src/analysis/risk_metrics.py
@tests/python/test_risk_metrics.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create dividend schedule config YAML and write failing tests</name>
  <files>
    fin-guru-private/dividend-schedules.yaml
    tests/python/test_total_return.py
  </files>
  <action>
**Step 1: Create dividend schedule config YAML at `fin-guru-private/dividend-schedules.yaml`**

This file stores per-ticker dividend frequency metadata used by the data quality validator (CONTEXT.md decision: "Detect gaps via known dividend schedule lookup in config YAML").

```yaml
# Dividend Schedule Configuration
# Used by TotalReturnCalculator to detect missing dividend data
# frequency: expected dividends per year
# schedule: human-readable schedule type

tickers:
  # Monthly payers
  CLM:
    frequency: 12
    schedule: monthly
  JEPI:
    frequency: 12
    schedule: monthly
  JEPQ:
    frequency: 12
    schedule: monthly
  MSTY:
    frequency: 12
    schedule: monthly
  AMZY:
    frequency: 12
    schedule: monthly
  SPYI:
    frequency: 12
    schedule: monthly
  QQQI:
    frequency: 12
    schedule: monthly

  # Weekly payers
  YMAX:
    frequency: 52
    schedule: weekly
  QQQY:
    frequency: 52
    schedule: weekly

  # Quarterly payers
  SCHD:
    frequency: 4
    schedule: quarterly
  VYM:
    frequency: 4
    schedule: quarterly
  VOO:
    frequency: 4
    schedule: quarterly
  SPY:
    frequency: 4
    schedule: quarterly
  AAPL:
    frequency: 4
    schedule: quarterly
  MSFT:
    frequency: 4
    schedule: quarterly
  QQQ:
    frequency: 4
    schedule: quarterly
```

**Step 2: Write failing tests in `tests/python/test_total_return.py`**

Follow the pattern from `tests/python/test_risk_metrics.py`. Use synthetic data only -- zero API calls. Organize into test classes.

**Helper fixtures needed:**

```python
from datetime import date, timedelta
from src.models.total_return_inputs import TotalReturnInput, DividendRecord, TickerReturn

def _make_dates(n: int, start: date | None = None) -> list[date]:
    """Generate n sequential dates."""
    start = start or date(2025, 1, 2)
    return [start + timedelta(days=i) for i in range(n)]
```

**Test classes to create (RED phase -- all tests should FAIL initially):**

1. **TestPriceReturn** (known-answer):
   - `test_price_return_positive`: prices [100, 110] -> 0.10 (10%)
   - `test_price_return_negative`: prices [100, 90] -> -0.10 (-10%)
   - `test_price_return_flat`: prices [100, 100] -> 0.0

2. **TestDividendReturn** (known-answer):
   - `test_dividend_return_single`: 1 dividend of $2.00, start price $100 -> 0.02 (2%)
   - `test_dividend_return_multiple`: 4 dividends of $0.50 each, start price $100 -> 0.02 (2%)
   - `test_dividend_return_zero`: no dividends -> 0.0

3. **TestTotalReturn** (known-answer):
   - `test_total_return_is_sum`: price_return + dividend_return == total_return
   - `test_total_return_negative_price_positive_total`: price drops 5% but dividends add 8% -> total +3% (the "Sean insight" scenario)

4. **TestDRIPReturn** (known-answer):
   - `test_drip_share_growth`: Start with 100 shares at $10, 1 dividend of $0.50/share at close price $10, DRIP buys 5 more shares -> 105 shares
   - `test_drip_return_exceeds_non_drip`: DRIP return should always >= non-DRIP return (compounding)
   - `test_drip_multiple_dividends`: 4 quarterly dividends, verify final share count matches manual calculation
   - `test_drip_and_non_drip_both_computed`: calculate_all() returns both values

5. **TestAnnualizedReturn**:
   - `test_annualized_uses_calendar_days`: 182 days of 10% total -> annualized with (1.10)^(365/182) - 1
   - `test_annualized_one_year`: 365 calendar days returns same as raw total return

6. **TestDataQualityValidation**:
   - `test_detects_missing_monthly_dividends`: CLM with 6 dividends in 365 days (expected ~12) -> returns warnings and refuses (raises or returns error indicator)
   - `test_detects_missing_quarterly_dividends`: SCHD with 1 dividend in 365 days (expected ~4) -> returns warnings
   - `test_accepts_complete_data`: SCHD with 4 dividends in 365 days -> no warnings, no refusal
   - `test_unknown_ticker_no_schedule_check`: ticker "XYZ" not in schedules -> no frequency check, no refusal
   - `test_force_overrides_refusal`: force=True skips the refusal, returns data with warnings attached
   - `test_split_artifact_detection`: one dividend 5x the median flagged as suspicious
   - `test_no_dividends_for_known_payer`: CLM with 0 dividends -> specific warning

7. **TestScheduleLoader**:
   - `test_load_dividend_schedules`: loads YAML file, returns dict with CLM -> 12, SCHD -> 4, QQQY -> 52
   - `test_missing_schedule_file_returns_empty`: no file -> returns empty dict (graceful fallback)

Run `uv run pytest tests/python/test_total_return.py` -- all tests should FAIL (RED) because `src/analysis/total_return.py` does not exist yet.

Commit: `test(07-01): add failing tests for TotalReturnCalculator`
  </action>
  <verify>
    `uv run pytest tests/python/test_total_return.py` -- tests collect but FAIL (ImportError or assertion errors). Zero passes expected.
  </verify>
  <done>
    - `fin-guru-private/dividend-schedules.yaml` exists with CLM (12), QQQY (52), SCHD (4), and at least 15 tickers
    - `tests/python/test_total_return.py` has 20+ tests organized into 7 test classes
    - All tests fail on import or assertion (RED phase complete)
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement TotalReturnCalculator to pass all tests</name>
  <files>
    src/analysis/total_return.py
  </files>
  <action>
**GREEN phase: Create `src/analysis/total_return.py` to make all tests pass.**

Follow the pattern from `src/analysis/risk_metrics.py` (Layer 2 calculator). The class imports models from `src/models/total_return_inputs.py` (already exists from Phase 6).

**Key design decisions from CONTEXT.md (LOCKED):**

1. **Three distinct returns**: price_return, dividend_return, total_return (TR-01)
2. **DRIP modeling**: reinvest at ex-date close price, track share count (TR-02)
3. **Both DRIP and non-DRIP computed together**: calculate_all() returns both (CONTEXT.md: "show both with DRIP and without DRIP side-by-side by default")
4. **Data quality validation refuses on gaps**: returns error indicator when dividend count is below expected (CONTEXT.md: "Refuse to calculate when dividend data has gaps")
5. **--force override**: when force=True, warn but do not refuse
6. **Annualize with calendar days (365)**, not trading days (252) (from RESEARCH.md)
7. **Split artifact detection**: flag dividends >3x median

**Class structure:**

```python
"""Total Return Calculator for Finance Guru.

Layer 2 calculator: computes price return, dividend return, total return,
and DRIP return with data quality validation.

ARCHITECTURE NOTE:
    Layer 1: Pydantic Models (src/models/total_return_inputs.py) - Data validation
    Layer 2: Calculator Classes (THIS FILE) - Business logic
    Layer 3: CLI Interface (total_return_cli.py) - Agent integration
"""

from __future__ import annotations

import logging
from datetime import date
from pathlib import Path

import yaml

from src.models.total_return_inputs import DividendRecord, TickerReturn, TotalReturnInput

logger = logging.getLogger(__name__)

PROJECT_ROOT = Path(__file__).parent.parent.parent
SCHEDULE_PATH = PROJECT_ROOT / "fin-guru-private" / "dividend-schedules.yaml"


def load_dividend_schedules(path: Path | None = None) -> dict[str, int]:
    """Load per-ticker expected dividend frequencies from YAML.

    Returns dict mapping ticker -> annual frequency (e.g., {"CLM": 12, "SCHD": 4}).
    Returns empty dict if file not found (graceful fallback).
    """
    target = path or SCHEDULE_PATH
    if not target.exists():
        return {}
    try:
        with open(target) as f:
            data = yaml.safe_load(f)
        if not isinstance(data, dict) or "tickers" not in data:
            return {}
        return {
            ticker: info["frequency"]
            for ticker, info in data["tickers"].items()
            if isinstance(info, dict) and "frequency" in info
        }
    except Exception:
        logger.warning("Failed to load dividend schedules from %s", target)
        return {}


class DividendDataError(Exception):
    """Raised when dividend data quality is insufficient and force is not set."""

    def __init__(self, warnings: list[str]):
        self.warnings = warnings
        super().__init__(
            f"Dividend data quality issues detected ({len(warnings)} warnings). "
            f"Use --force to override."
        )


class TotalReturnCalculator:
    """Calculate price return, dividend return, total return, and DRIP return.

    Accepts a list of raw close prices, a list of dates, and a list of
    DividendRecord objects. All calculations use raw Close prices (NOT Adj Close)
    to avoid double-counting dividends.
    """

    def __init__(
        self,
        ticker: str,
        prices: list[float],
        dates: list[date],
        dividends: list[DividendRecord],
        initial_shares: float = 1.0,
        force: bool = False,
        schedules: dict[str, int] | None = None,
    ):
        ...  # Store parameters

    def calculate_price_return(self) -> float:
        """(ending_price - starting_price) / starting_price"""

    def calculate_dividend_return(self) -> float:
        """sum(dividends_per_share) / starting_price
        Non-DRIP: uses initial share count throughout."""

    def calculate_total_return(self) -> float:
        """price_return + dividend_return (non-DRIP)"""

    def calculate_drip_return(self) -> tuple[float, float, list[dict]]:
        """Reinvest each dividend at ex-date close price.

        Returns: (drip_total_return, final_shares, period_breakdown)

        period_breakdown is a list of dicts, one per dividend event:
        {
            "ex_date": date,
            "dividend_per_share": float,
            "shares_before": float,
            "dividend_cash": float,
            "shares_acquired": float,
            "shares_after": float,
            "reinvest_price": float,
        }
        """

    def calculate_annualized_return(self, total_return: float) -> float:
        """Annualize using calendar days: (1 + total_return) ** (365 / calendar_days) - 1"""

    def validate_dividend_data(self) -> list[str]:
        """Check for data quality issues.

        Checks:
        1. Expected frequency vs actual count (using dividend-schedules.yaml)
        2. Split artifact detection (dividend > 3x median)
        3. No dividends for known dividend payer

        Returns list of warning strings. If not empty AND force=False,
        calculate_all() will raise DividendDataError.
        """

    def calculate_all(self) -> TickerReturn:
        """Run all calculations and return validated output.

        Flow:
        1. Validate dividend data quality
        2. If warnings and not force: raise DividendDataError
        3. If warnings and force: attach warnings to output
        4. Calculate price_return, dividend_return, total_return (non-DRIP)
        5. Calculate drip_return and drip_final_shares
        6. Return TickerReturn with all fields populated

        NOTE: TickerReturn from Phase 6 does NOT have annualized_return,
        drip_total_return, or drip_share_growth fields. Store these as:
        - annualized_return: computed but returned separately or stored in a wrapper
        - drip info: returned via a supplementary dataclass/dict

        The return type should be a richer result object or a tuple:
        (TickerReturn, drip_info_dict, annualized_return)
        OR define a TotalReturnResult dataclass that wraps TickerReturn with
        the additional fields.
        """
```

**IMPORTANT implementation details:**

- **TotalReturnResult dataclass**: Since TickerReturn from Phase 6 lacks annualized_return, drip_total_return, drip_share_growth, and period_breakdown, create a `TotalReturnResult` dataclass (or Pydantic model) in this file that wraps TickerReturn and adds these fields. This avoids modifying the Phase 6 model.
- **period_breakdown**: list of dicts for every individual dividend event (CONTEXT.md: "Period breakdown shows every individual dividend event: date, dividend/share, shares acquired, running total"). Full granularity even for weekly payers.
- **Use raw Close prices** for all calculations. Do NOT use Adj Close.
- **DividendRecord.shares_at_ex**: Note that the Phase 6 DividendRecord has `shares_at_ex` field. For non-DRIP mode, this stays at initial_shares. For DRIP mode, this grows with each reinvestment. The calculator should populate this field correctly.
- **Tolerance for schedule check**: use 25% tolerance (same as RESEARCH.md): if actual_count < expected_count * 0.75, flag as gap.

Run `uv run pytest tests/python/test_total_return.py` -- all tests should PASS (GREEN).

Commit: `feat(07-01): implement TotalReturnCalculator with DRIP and data quality validation`

**REFACTOR phase:** If obvious cleanup needed, refactor and verify tests still pass. Commit: `refactor(07-01): clean up TotalReturnCalculator`
  </action>
  <verify>
    `uv run pytest tests/python/test_total_return.py -v` -- all 20+ tests pass.
    `uv run pytest --cov=src/analysis/total_return --cov-report=term-missing` -- >90% coverage on calculator module.
    `uv run ruff check src/analysis/total_return.py` -- zero errors.
    `uv run mypy src/analysis/total_return.py` -- no type errors (or only pre-existing ignores).
  </verify>
  <done>
    - `src/analysis/total_return.py` exists with TotalReturnCalculator class
    - TotalReturnCalculator has methods: calculate_price_return(), calculate_dividend_return(), calculate_total_return(), calculate_drip_return(), calculate_annualized_return(), validate_dividend_data(), calculate_all()
    - load_dividend_schedules() function loads from fin-guru-private/dividend-schedules.yaml
    - DividendDataError exception raised when data has gaps and force=False
    - TotalReturnResult (or equivalent) wraps TickerReturn with annualized_return, drip_total_return, drip_share_growth, and period_breakdown
    - All 20+ tests pass, ruff clean, mypy clean
  </done>
</task>

</tasks>

<verification>
1. `uv run pytest tests/python/test_total_return.py -v` -- all tests pass
2. `uv run pytest` -- full test suite passes (no regressions)
3. `uv run ruff check src/analysis/total_return.py tests/python/test_total_return.py` -- clean
4. Verify TotalReturnCalculator produces three distinct numbers for a known scenario:
   - prices [100, 95], 1 dividend of $8.00 -> price_return = -0.05, dividend_return = 0.08, total_return = 0.03
   - This is the "Sean insight" scenario: price is down but total return is positive
5. Verify DRIP calculation: 100 shares at $10, dividend $0.50/share at close $10 -> buys 5 shares -> 105 total
6. Verify data quality: CLM with 6 dividends in 365 days raises DividendDataError (expected ~12)
7. Verify force=True: same scenario returns result with warnings attached
</verification>

<success_criteria>
- TotalReturnCalculator is a working Layer 2 calculator following the same pattern as RiskCalculator
- Three distinct returns computed correctly with known-answer verification
- DRIP models growing share count with per-event period breakdown
- Data quality validation refuses on gaps, allows with --force
- Dividend schedules loaded from YAML config file
- 20+ tests all passing with >90% calculator coverage
</success_criteria>

<output>
After completion, create `.planning/phases/07-total-return-calculator/07-01-SUMMARY.md`
</output>
