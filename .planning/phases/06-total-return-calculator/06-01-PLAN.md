---
phase: 06-total-return-calculator
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/analysis/total_return.py
autonomous: true

must_haves:
  truths:
    - "TotalReturnCalculator accepts a TotalReturnInput and list of prices/dividends, computes price return, dividend return, total return, and DRIP return"
    - "Price return is (ending_price - starting_price) / starting_price using raw Close prices (not Adjusted Close)"
    - "Dividend return is sum(dividends) / starting_price"
    - "DRIP reinvests each dividend at ex-date close price, accumulating fractional shares"
    - "validate_dividend_data() detects missing dividends by comparing actual count against expected frequency"
    - "validate_dividend_data() flags dividend amounts >3x the median as possible split artifacts"
    - "calculate_all() returns a validated TickerReturn with all fields populated including data_quality_warnings"
    - "Annualized return uses calendar days: (1 + total_return) ** (365 / days) - 1"
  artifacts:
    - path: "src/analysis/total_return.py"
      provides: "TotalReturnCalculator class and fetch_ticker_data function"
      exports: ["TotalReturnCalculator", "fetch_ticker_data", "EXPECTED_DIVIDEND_FREQUENCIES"]
  key_links:
    - from: "src/analysis/total_return.py"
      to: "src/models/total_return_inputs.py"
      via: "import TotalReturnInput, DividendRecord, TickerReturn"
      pattern: "from src\\.models\\.total_return_inputs import"
    - from: "src/analysis/total_return.py"
      to: "yfinance"
      via: "yf.Ticker(symbol).history() for synchronized price+dividend data"
      pattern: "yf\\.Ticker"
---

<objective>
Build the TotalReturnCalculator class (Layer 2) and the data fetching function that powers the total return CLI.

Purpose: This is the calculation engine for Phase 6. It computes price return, dividend return, total return (simple and DRIP), and validates yfinance dividend data quality. Without this, the CLI (Plan 02) has nothing to call.

Output:
- `src/analysis/total_return.py` with TotalReturnCalculator class, fetch_ticker_data function, and EXPECTED_DIVIDEND_FREQUENCIES dict
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-total-return-calculator/06-RESEARCH.md

# Phase 5 creates the models this plan imports
@.planning/phases/05-config-loader-shared-hedging-models/05-01-PLAN.md

# Pattern references (read these for exact conventions)
@src/analysis/risk_metrics.py
@src/analysis/correlation.py
@src/models/total_return_inputs.py
@src/CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TotalReturnCalculator class with all calculation methods</name>
  <files>src/analysis/total_return.py</files>
  <action>
Create `src/analysis/total_return.py` following the established Layer 2 calculator pattern from `risk_metrics.py` and `correlation.py`.

**File structure:**
1. Shebang line `#!/usr/bin/env python3`
2. Module docstring with ARCHITECTURE NOTE (Layer 2 of 3), AGENT USAGE examples showing `uv run python src/analysis/total_return_cli.py SCHD --days 252`, EDUCATIONAL NOTE about total return = price + dividend + DRIP
3. Imports: `from datetime import date, timedelta`, `from datetime import datetime`, `import numpy as np`, `import pandas as pd`, `import yfinance as yf`, `import sys`, `from pathlib import Path`
4. Project root path setup (same pattern as `correlation_cli.py` lines 36-37): `project_root = Path(__file__).parent.parent.parent; sys.path.insert(0, str(project_root))`
5. Import from models: `from src.models.total_return_inputs import TotalReturnInput, DividendRecord, TickerReturn`

**EXPECTED_DIVIDEND_FREQUENCIES dict** (module-level constant):
```python
EXPECTED_DIVIDEND_FREQUENCIES: dict[str, int] = {
    # Monthly dividend ETFs/funds
    "JEPI": 12, "JEPQ": 12, "QQQI": 12, "SPYI": 12,
    "YMAX": 12, "MSTY": 12, "AMZY": 12,
    # Quarterly dividend ETFs/stocks
    "SCHD": 4, "VYM": 4, "VOO": 4, "SPY": 4,
    "VTI": 4, "QQQ": 4, "AAPL": 4, "MSFT": 4,
    "JNJ": 4, "PG": 4, "KO": 4, "PEP": 4,
}
```

**fetch_ticker_data function:**
```python
def fetch_ticker_data(ticker: str, days: int) -> tuple[list[float], list[date], list[DividendRecord]]:
```
- Fetch `yf.Ticker(ticker).history(start=start_date, end=end_date)` where `start_date = datetime.now() - timedelta(days=int(days * 1.5))` (1.5x buffer for weekends/holidays, same pattern as research)
- Extract `prices = hist['Close'].tolist()` -- use raw Close, NOT Adj Close (anti-pattern from research: mixing Adj Close with explicit dividends double-counts)
- Extract `dates = [d.date() for d in hist.index]` -- normalize timezone-aware to naive (pitfall #4 from research)
- Extract non-zero dividends: filter `hist['Dividends'] > 0`, create `DividendRecord(ex_date=d.date(), amount=row['Dividends'], shares_at_ex=1.0)` for each
- Trim to requested `days` from the end (the 1.5x buffer ensures enough trading days)
- If fewer than 2 price points after trim, raise `ValueError(f"Insufficient data for {ticker}: got {len(prices)} price points, need at least 2")`
- Return `(prices, dates, dividends_within_period)`

**TotalReturnCalculator class:**
Constructor: `__init__(self, prices: list[float], dates: list[date], dividends: list[DividendRecord], ticker: str = "UNKNOWN", include_drip: bool = True)`
- Store all params as instance attributes
- `self._starting_price = prices[0]`
- `self._ending_price = prices[-1]`
- `self._period_days = (dates[-1] - dates[0]).days`

Methods:

`calculate_price_return(self) -> float`:
- `return (self._ending_price - self._starting_price) / self._starting_price`

`calculate_dividend_return(self) -> float`:
- `total_dividends = sum(d.amount for d in self.dividends)`
- `return total_dividends / self._starting_price`

`calculate_total_return(self) -> float`:
- `return self.calculate_price_return() + self.calculate_dividend_return()`

`calculate_drip_return(self) -> tuple[float, float, float]`:
- Start with `shares = 1.0` (or `self.initial_shares` if you add that param)
- `initial_value = shares * self._starting_price`
- For each dividend in `self.dividends`: `dividend_cash = shares * div.amount`, `new_shares = dividend_cash / div.close_price_at_ex` -- BUT DividendRecord from Phase 5 has `shares_at_ex` not `close_price`. We need the close price at ex-date. Look it up from `self.prices` and `self.dates` by finding the matching date index. If ex_date not found in dates (weekend edge case), use the next available trading day's close price.
- After all dividends: `final_value = shares * self._ending_price`, `drip_return = (final_value / initial_value) - 1.0`, `share_growth = shares / 1.0 - 1.0`
- Return `(drip_return, shares, share_growth)`

**CRITICAL for DRIP:** The DividendRecord from Phase 5 has `amount` and `ex_date` but the close price at ex-date must come from the price series. Build a date->price lookup dict in `__init__`: `self._date_price_map = dict(zip(self.dates, self.prices))`. In DRIP, look up `close_at_ex = self._date_price_map.get(div.ex_date)`. If not found (ex-date falls on non-trading day), find the nearest following trading day.

`_annualize(self, total_return: float) -> float`:
- `if self._period_days <= 0: return 0.0`
- `return (1 + total_return) ** (365 / self._period_days) - 1`
- Use calendar days (365), NOT trading days (252). Research explicitly warns against hardcoding 252 for dividend-inclusive returns.

`validate_dividend_data(self) -> list[str]`:
- Implement all three checks from research:
  1. **Expected frequency check:** If ticker in EXPECTED_DIVIDEND_FREQUENCIES, compare `expected_count = max(1, int(freq * self._period_days / 365))` vs `actual_count = len(self.dividends)`. If actual < expected * 0.75, warn.
  2. **Split artifact check:** If 2+ dividends, compute median amount. Flag any dividend >3x median as possible split artifact.
  3. **Zero dividends for known payer:** If ticker in EXPECTED_DIVIDEND_FREQUENCIES and 0 dividends found, warn that yfinance may have data gaps.
- Also add: if `self._period_days < 90` and no dividends found, warn "Period may be too short to capture dividend payments. Consider using --days 252 for meaningful dividend analysis."
- Return list of warning strings.

`calculate_all(self) -> TickerReturn`:
- Call all methods, build TickerReturn:
```python
warnings = self.validate_dividend_data()
price_ret = self.calculate_price_return()
div_ret = self.calculate_dividend_return()
total_ret = self.calculate_total_return()

drip_ret, final_shares, share_growth = (None, 1.0, 0.0)
if self.include_drip and self.dividends:
    drip_ret, final_shares, share_growth = self.calculate_drip_return()

return TickerReturn(
    ticker=self.ticker,
    start_date=self.dates[0],
    end_date=self.dates[-1],
    price_return=price_ret,
    dividend_return=div_ret,
    total_return=total_ret if drip_ret is None else drip_ret,
    dividends=self.dividends,
    final_shares=final_shares,
    data_quality_warnings=warnings,
)
```

**NOTE on TickerReturn model fit:** The Phase 5 TickerReturn model has `price_return`, `dividend_return`, `total_return`, `dividends`, `final_shares`, `data_quality_warnings`. If the model shape from Phase 5 differs slightly from what this calculator needs, adapt the calculator output to match the model. Do NOT modify the Phase 5 model from this plan. If fields are missing (like `annualized_return` or `drip_total_return` or `drip_share_growth`), store them as extra fields on the return or extend TickerReturn only if the model supports it. If the model is strict, add a separate dataclass or namedtuple for the CLI to consume alongside TickerReturn.

**Anti-patterns to avoid:**
- Do NOT use Adj Close (double-counts dividends)
- Do NOT use `yf.download()` for dividend data (unreliable for multi-ticker)
- Do NOT annualize with 252 trading days (use 365 calendar days)
- Do NOT round intermediate calculations (only round display values)
  </action>
  <verify>
Run: `uv run python -c "from src.analysis.total_return import TotalReturnCalculator, fetch_ticker_data, EXPECTED_DIVIDEND_FREQUENCIES; print('Import OK')"` -- must print Import OK.

Verify calculator with synthetic data:
```bash
uv run python -c "
from src.analysis.total_return import TotalReturnCalculator
from src.models.total_return_inputs import DividendRecord
from datetime import date

# Known-answer test: stock goes from 100 to 110, one dividend of 2.00
prices = [100.0, 102.0, 105.0, 103.0, 108.0, 110.0]
dates = [date(2025,1,2), date(2025,1,3), date(2025,1,6), date(2025,1,7), date(2025,1,8), date(2025,1,9)]
divs = [DividendRecord(ex_date=date(2025,1,6), amount=2.0, shares_at_ex=1.0)]

calc = TotalReturnCalculator(prices=prices, dates=dates, dividends=divs, ticker='TEST')
print(f'Price return: {calc.calculate_price_return():.4f}')  # Expected: 0.10 (10%)
print(f'Dividend return: {calc.calculate_dividend_return():.4f}')  # Expected: 0.02 (2%)
print(f'Total return: {calc.calculate_total_return():.4f}')  # Expected: 0.12 (12%)
result = calc.calculate_all()
print(f'TickerReturn total: {result.total_return}')
print('Calculator OK')
"
```

Verify data quality warnings:
```bash
uv run python -c "
from src.analysis.total_return import TotalReturnCalculator
from datetime import date

# SCHD with zero dividends over 252 days should warn
prices = [100.0] * 252
dates = [date(2025, 1, 1 + i) if i < 28 else date(2025, 2, i - 27) for i in range(252)]
# Simplified: just need start/end spread
import datetime
start = date(2025, 1, 2)
dates_real = [start + datetime.timedelta(days=i) for i in range(252)]
prices_real = [100.0 + i * 0.1 for i in range(252)]

calc = TotalReturnCalculator(prices=prices_real, dates=dates_real, dividends=[], ticker='SCHD')
warnings = calc.validate_dividend_data()
print(f'Warnings: {warnings}')
assert len(warnings) > 0, 'Expected warnings for SCHD with no dividends'
print('Validation OK')
"
```
  </verify>
  <done>
TotalReturnCalculator class exists in src/analysis/total_return.py with:
- calculate_price_return() returning (end - start) / start
- calculate_dividend_return() returning sum(divs) / start
- calculate_total_return() returning price + dividend return
- calculate_drip_return() returning (drip_return, final_shares, share_growth) with ex-date reinvestment
- validate_dividend_data() returning warnings for frequency gaps, split artifacts, zero dividends
- calculate_all() returning a populated TickerReturn model
- fetch_ticker_data() using yf.Ticker().history() with raw Close prices
- EXPECTED_DIVIDEND_FREQUENCIES dict for gap detection
  </done>
</task>

</tasks>

<verification>
1. Import check: `uv run python -c "from src.analysis.total_return import TotalReturnCalculator, fetch_ticker_data; print('OK')"`
2. Known-answer price return: stock 100 -> 110 = 10% (0.10)
3. Known-answer dividend return: $2 dividend on $100 start = 2% (0.02)
4. Known-answer total return: 10% + 2% = 12% (0.12)
5. DRIP return: $2 dividend reinvested at $105 close = 0.019 new shares, final value = 1.019 * 110 = 112.09, DRIP return = 12.09%
6. Data quality: SCHD with 0 dividends over 252 days produces warning
7. Data quality: dividend 10x median flagged as split artifact
</verification>

<success_criteria>
1. TotalReturnCalculator importable and constructable with price/date/dividend lists
2. All five calculation methods return correct values for known inputs
3. validate_dividend_data() produces non-empty warnings for known gap scenarios
4. fetch_ticker_data() calls yf.Ticker().history() and returns prices, dates, dividends
5. No usage of Adj Close anywhere in the file
6. Annualization uses 365 calendar days, not 252 trading days
</success_criteria>

<output>
After completion, create `.planning/phases/06-total-return-calculator/06-01-SUMMARY.md`
</output>
